

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Wavelength-dependent Profiles &mdash; GalSim 2.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Weak Lensing Shear" href="shear.html" />
    <link rel="prev" title="Noise and Random Values" href="noise.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Noise and Random Values</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Wavelength-dependent Profiles</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#spectral-energy-distributions">Spectral Energy Distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bandpass-filters">Bandpass Filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#chromatic-profiles">Chromatic Profiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spectral-correlated-noise">Spectral Correlated Noise</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="shear.html">Weak Lensing Shear</a></li>
<li class="toctree-l1"><a class="reference internal" href="coord.html">Angles and Coordinates</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Wavelength-dependent Profiles</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/chromatic.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="wavelength-dependent-profiles">
<h1>Wavelength-dependent Profiles<a class="headerlink" href="#wavelength-dependent-profiles" title="Permalink to this headline">¶</a></h1>
<p>Real astronomical objects emit photons at a range of wavelengths according to a potentially
complicated spectral energy distribution (SED).  These photons then may be affected differently
by the atmosphere and optics as part of the point-spread function (PSF).  Then they typically
pass through a bandpass filter with a variable transmission as a function of wavelength.
Finally, there may be other wavelength-dependent effects when converting from photons to
electrons in the sensor.</p>
<p>GalSim supplies a number of tools to simulate these chromatic effects.
An <a class="reference internal" href="#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a> is used to define the SED of the objects.  There are a variety of options as to the units
of the input SED function; e.g. photons/cm^2/nm/sec, ergs/cm^2/Hz/s, etc.  There are also ways
to adjust the normalization of the SED to give a particular observed magnitude when observed
in through particular <a class="reference internal" href="#galsim.Bandpass" title="galsim.Bandpass"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Bandpass</span></code></a>.  There is also a dimensionless option, which may be appropriate
for defining chromatic PSFs.</p>
<p>The <a class="reference internal" href="#galsim.Bandpass" title="galsim.Bandpass"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Bandpass</span></code></a> class represents a spectral throughput function, which could be an
entire imaging system throughput response function (reflection off of mirrors, transmission through
filters, lenses and the atmosphere, quantum efficiency of detectors), or individual pieces thereof.
Both a <a class="reference internal" href="#galsim.Bandpass" title="galsim.Bandpass"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Bandpass</span></code></a> and the <a class="reference internal" href="#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a> are necessary to compute the relative contribution of each
wavelength of a <a class="reference internal" href="#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a> to a drawn image.</p>
<p>Then there are a number of kinds of <a class="reference internal" href="#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a> to define the wavelength dependence of an
object’s surface brightness profile.  The simplest one is when the spatial and spectral
dependencies are separable; i.e. every part of the profile has the same SED.  In this case,
one forms the <a class="reference internal" href="#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a> simply by multiplying a <a class="reference internal" href="gsobject.html#galsim.GSObject" title="galsim.GSObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">GSObject</span></code></a> by an <a class="reference internal" href="#galsim.SED" title="galsim.SED"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SED</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Sersic</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mf">2.3</span><span class="p">,</span> <span class="n">half_light_radius</span><span class="o">=</span><span class="mf">3.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sed</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="s1">&#39;CWW_Sbc_ext.sed&#39;</span><span class="p">,</span> <span class="n">wave_type</span><span class="s1">&#39;Ang&#39;</span><span class="p">,</span> <span class="n">flux_type</span><span class="o">=</span><span class="s1">&#39;flambda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chromatic_object</span> <span class="o">=</span> <span class="n">obj</span> <span class="o">*</span> <span class="n">sed</span>
</pre></div>
</div>
<p>Other more complicated kinds of chromatic profiles are subclasses of <a class="reference internal" href="#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a> and
have their own initialization arguments.  See the listings below.</p>
<p>To draw any kind of <a class="reference internal" href="#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a>, you call its <a class="reference internal" href="#galsim.ChromaticObject.drawImage" title="galsim.ChromaticObject.drawImage"><code class="xref py py-meth docutils literal notranslate"><span class="pre">drawImage()</span></code></a>
method, which works largely the same as <code class="xref py py-meth docutils literal notranslate"><span class="pre">GSObject:drawImage()</span></code>, but requires a
<a class="reference internal" href="#galsim.Bandpass" title="galsim.Bandpass"><code class="xref any py py-class docutils literal notranslate"><span class="pre">galsim.Bandpass</span></code></a> argument to define what bandpass is being used for the observation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gband</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Bandpass</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">wave_type</span><span class="o">=</span><span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="n">blue_limit</span><span class="o">=</span><span class="mi">410</span><span class="p">,</span> <span class="n">red_limit</span><span class="o">=</span><span class="mi">550</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">chromatic_obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">gband</span><span class="p">)</span>
</pre></div>
</div>
<p>The transformation methods of <a class="reference internal" href="#galsim.ChromaticObject" title="galsim.ChromaticObject"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticObject</span></code></a>, like <code class="xref py py-meth docutils literal notranslate"><span class="pre">dilate()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">shift()</span></code>,
can also accept as an argument a function of wavelength (in nanometers)
that returns a wavelength-dependent dilation, shift, etc.  These can be used to implement
chromatic PSFs.  For example, a diffraction limited PSF might look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">psf500</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Airy</span><span class="p">(</span><span class="n">lam_over_diam</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chromatic_psf</span> <span class="o">=</span> <span class="n">ChromaticObject</span><span class="p">(</span><span class="n">psf500</span><span class="p">)</span><span class="o">.</span><span class="n">dilate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:(</span><span class="n">w</span><span class="o">/</span><span class="mi">500</span><span class="p">)</span><span class="o">**</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="spectral-energy-distributions">
<h2>Spectral Energy Distributions<a class="headerlink" href="#spectral-energy-distributions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.SED">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">SED</code><span class="sig-paren">(</span><em class="sig-param">spec</em>, <em class="sig-param">wave_type</em>, <em class="sig-param">flux_type</em>, <em class="sig-param">redshift=0.0</em>, <em class="sig-param">fast=True</em>, <em class="sig-param">_blue_limit=0.0</em>, <em class="sig-param">_red_limit=inf</em>, <em class="sig-param">_wave_list=None</em>, <em class="sig-param">_spectral=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED" title="Permalink to this definition">¶</a></dt>
<dd><p>Object to represent the spectral energy distributions of stars and galaxies.</p>
<p>SEDs are callable, usually returning the flux density in photons/nm/cm^2/s as a function of
wavelength, though SEDs are also used by GalSim to track dimensionless wavelength-dependent
normalizations, and may thus also return dimensionless values.  By default, the above wavelength
used by __call__ is nanometers, but it’s possible to use other units via the astropy.units
module (at least, if the SED keyword argument <code class="docutils literal notranslate"><span class="pre">fast=False</span></code>, see below).  For instance,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sed</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">astropy</span> <span class="k">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">sed</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span> <span class="o">==</span> <span class="n">sed</span><span class="p">(</span><span class="mi">5000</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">AA</span><span class="p">)</span>  <span class="c1"># 500 nm == 5000 Angstroms</span>
</pre></div>
</div>
<p>The python type of the return value depends on the type of the input wavelength(s).  A scalar
input wavelength yields a scalar flux density, a tuple yields a tuple, a list yields a list, and
a numpy.ndarray yields a numpy.ndarray.  A scalar astropy.units.Quantity yields a python scalar,
and a vector astropy.units.Quantity yields a numpy.ndarray.</p>
<p>SEDs are immutable; all transformative SED methods return <em>new</em> SEDs, and leave their
originating SEDs unaltered.</p>
<p>SEDs have <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">red_limit</span></code> attributes, which indicate the range over which the SED
is defined.  An exception will be raised if the flux density or normalization is requested
outside of this range.  Note that <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">red_limit</span></code> are always in nanometers and in
the observed frame when <code class="docutils literal notranslate"><span class="pre">redshift</span> <span class="pre">!=</span> <span class="pre">0</span></code>.</p>
<p>SEDs may be multiplied by scalars or scalar functions of wavelength.  In particular, an SED
multiplied by a <a class="reference internal" href="#galsim.Bandpass" title="galsim.Bandpass"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Bandpass</span></code></a> will yield the appropriately filtered SED.  Two SEDs may be
multiplied together if at least one of them represents a dimensionless normalization.</p>
<p>SEDs may be added together if they are at the same redshift.  The resulting SED will only be
defined on the wavelength region where both of the operand SEDs are defined. <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and
<code class="docutils literal notranslate"><span class="pre">red_limit</span></code> will be reset accordingly.</p>
<p>The input parameter, <code class="docutils literal notranslate"><span class="pre">spec</span></code>, may be one of several possible forms:</p>
<ol class="arabic simple">
<li><p>a regular python function (or an object that acts like a function)</p></li>
<li><p>a LookupTable</p></li>
<li><p>a file from which a LookupTable can be read in</p></li>
<li><p>a string which can be evaluated into a function of <code class="docutils literal notranslate"><span class="pre">wave</span></code> via eval(‘lambda wave : ‘+spec),
e.g., spec = ‘0.8 + 0.2 * (wave-800)’</p></li>
<li><p>a python scalar (only possible for dimensionless SEDs)</p></li>
</ol>
<p>The argument of <code class="docutils literal notranslate"><span class="pre">spec</span></code> should be the wavelength in units specified by <code class="docutils literal notranslate"><span class="pre">wave_type</span></code>, which should
be an instance of <code class="docutils literal notranslate"><span class="pre">astropy.units.Unit</span></code> of equivalency class <code class="docutils literal notranslate"><span class="pre">astropy.units.spectral</span></code>, or one of
the case-insensitive aliases ‘nm’, ‘nanometer’, ‘nanometers’, ‘A’, ‘Ang’, ‘Angstrom’, or
‘Angstroms’.  Note that <code class="docutils literal notranslate"><span class="pre">astropy.units.spectral</span></code> includes not only units with dimensions of
length, but also frequency, energy, or wavenumber.</p>
<p>The return value of <code class="docutils literal notranslate"><span class="pre">spec</span></code> should be a spectral density with units specified by <code class="docutils literal notranslate"><span class="pre">flux_type</span></code>,
which should be an instance of <code class="docutils literal notranslate"><span class="pre">astropy.units.Unit</span></code> of equivalency class
<code class="docutils literal notranslate"><span class="pre">astropy.units.spectral_density</span></code>, or one of the case-insensitive aliases:</p>
<ol class="arabic simple">
<li><p>‘flambda’:  erg/wave_type/cm^2/s, where wave_type is as above.</p></li>
<li><p>‘fnu’:      erg/Hz/cm^2/s</p></li>
<li><p>‘fphotons’: photons/wave_type/cm^2/s, where wave_type is as above.</p></li>
<li><p>‘1’:        dimensionless</p></li>
</ol>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">astropy.units.spectral_density</span></code> class includes units with dimensions of
[energy/time/area/unit-wavelength], [energy/time/area/unit-frequency],
[photons/time/area/unit-wavelength], and so on.</p>
<p>Finally, the optional <code class="docutils literal notranslate"><span class="pre">fast</span></code> keyword option is used to specify when unit and dimension changes
are executed, particularly for SEDs specified by a LookupTable.  If <code class="docutils literal notranslate"><span class="pre">fast=True</span></code>, the default,
then the input units/dimensions may be converted to an internal working unit before
interpolation in wavelength is performed.  Alternatively, <code class="docutils literal notranslate"><span class="pre">fast=False</span></code> implies that
interpolation should take place in the native units of the input <code class="docutils literal notranslate"><span class="pre">spec</span></code>, and subsequently flux
density converted to photons/cm^2/s/nm afterwards.  Generally, the former option is faster, but
may be less accurate since interpolation and dimensionality conversion do not commute.  One
consequence of using <code class="docutils literal notranslate"><span class="pre">fast=True</span></code> is that __call__ can not accept an <code class="docutils literal notranslate"><span class="pre">astropy.units.Quantity</span></code>
in this case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spec</strong> – Function defining the z=0 spectrum at each wavelength.  See above for
valid options for this parameter.</p></li>
<li><p><strong>wave_type</strong> – String or astropy.unit specifying units for wavelength input to <code class="docutils literal notranslate"><span class="pre">spec</span></code>.</p></li>
<li><p><strong>flux_type</strong> – String or astropy.unit specifying what type of spectral density or
dimensionless normalization <code class="docutils literal notranslate"><span class="pre">spec</span></code> represents.  See above for valid options
for this parameter.</p></li>
<li><p><strong>redshift</strong> – Optionally shift the spectrum to the given redshift. [default: 0]</p></li>
<li><p><strong>fast</strong> – Convert units on initialization instead of on __call__. [default: True]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.SED.atRedshift">
<code class="sig-name descname">atRedshift</code><span class="sig-paren">(</span><em class="sig-param">redshift</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.atRedshift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.atRedshift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new SED with redshifted wavelengths.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>redshift</strong> – The redshift for the returned SED</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the redshifted SED.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.calculateDCRMomentShifts">
<code class="sig-name descname">calculateDCRMomentShifts</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.calculateDCRMomentShifts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.calculateDCRMomentShifts" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates shifts in first and second moments of PSF due to differential chromatic
refraction (DCR).  I.e., equations (1) and (2) from Plazas and Bernstein (2012)
(<a class="reference external" href="http://arxiv.org/abs/1204.1346">http://arxiv.org/abs/1204.1346</a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – Bandpass through which object is being imaged.</p></li>
<li><p><strong>zenith_angle</strong> – Angle from object to zenith, expressed as an Angle</p></li>
<li><p><strong>parallactic_angle</strong> – Parallactic angle, i.e. the position angle of the zenith,
measured from North through East.  [default: 0]</p></li>
<li><p><strong>obj_coord</strong> – Celestial coordinates of the object being drawn as a
CelestialCoord. [default: None]</p></li>
<li><p><strong>zenith_coord</strong> – Celestial coordinates of the zenith as a CelestialCoord.
[default: None]</p></li>
<li><p><strong>HA</strong> – Hour angle of the object as an Angle. [default: None]</p></li>
<li><p><strong>latitude</strong> – Latitude of the observer as an Angle. [default: None]</p></li>
<li><p><strong>pressure</strong> – Air pressure in kiloPascals.  [default: 69.328 kPa]</p></li>
<li><p><strong>temperature</strong> – Temperature in Kelvins.  [default: 293.15 K]</p></li>
<li><p><strong>H2O_pressure</strong> – Water vapor pressure in kiloPascals.  [default: 1.067 kPa]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>The first element is the vector of DCR first moment shifts</p></li>
<li><p>The second element is the 2x2 matrix of DCR second (central) moment shifts.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.calculateFlux">
<code class="sig-name descname">calculateFlux</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.calculateFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.calculateFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the flux (photons/cm^2/s) of the SED through the bandpass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bandpass</strong> – A Bandpass object representing a filter, or None to compute the bolometric
flux.  For the bolometric flux the integration limits will be set to
(0, infinity), which implies that the SED needs to be evaluable over
this entire range.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the flux through the bandpass.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.calculateMagnitude">
<code class="sig-name descname">calculateMagnitude</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.calculateMagnitude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.calculateMagnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the SED magnitude through a Bandpass <code class="docutils literal notranslate"><span class="pre">bandpass</span></code>.  Note that this requires
<code class="docutils literal notranslate"><span class="pre">bandpass</span></code> to have been assigned a zeropoint using <a class="reference internal" href="#galsim.Bandpass.withZeropoint" title="galsim.Bandpass.withZeropoint"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Bandpass.withZeropoint</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bandpass</strong> – A Bandpass object representing a filter, or None to compute the
bolometric magnitude.  For the bolometric magnitude the integration
limits will be set to (0, infinity), which implies that the SED needs to
be evaluable over this entire range.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bandpass magnitude.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.calculateSeeingMomentRatio">
<code class="sig-name descname">calculateSeeingMomentRatio</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em>, <em class="sig-param">alpha=-0.2</em>, <em class="sig-param">base_wavelength=500</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.calculateSeeingMomentRatio"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.calculateSeeingMomentRatio" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the relative size of a PSF compared to the monochromatic PSF size at
wavelength <code class="docutils literal notranslate"><span class="pre">base_wavelength</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – Bandpass through which object is being imaged.</p></li>
<li><p><strong>alpha</strong> – Power law index for wavelength-dependent seeing.  [default:
-0.2, the prediction for Kolmogorov turbulence]</p></li>
<li><p><strong>base_wavelength</strong> – Reference wavelength in nm from which to compute the relative
PSF size.  [default: 500]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the ratio of the PSF second moments to the second moments of the reference PSF.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.check_dimensionless">
<code class="sig-name descname">check_dimensionless</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.check_dimensionless"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.check_dimensionless" title="Permalink to this definition">¶</a></dt>
<dd><p>Return boolean indicating if SED is dimensionless.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.check_spectral">
<code class="sig-name descname">check_spectral</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.check_spectral"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.check_spectral" title="Permalink to this definition">¶</a></dt>
<dd><p>Return boolean indicating if SED has units compatible with a spectral density.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.sampleWavelength">
<code class="sig-name descname">sampleWavelength</code><span class="sig-paren">(</span><em class="sig-param">nphotons</em>, <em class="sig-param">bandpass</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">npoints=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.sampleWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.sampleWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a number of random wavelength values from the SED, possibly as observed through
a bandpass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nphotons</strong> – Number of samples (photons) to randomly draw.</p></li>
<li><p><strong>bandpass</strong> – A Bandpass object representing a filter, or None to sample over the full
SED wavelength range.</p></li>
<li><p><strong>rng</strong> – If provided, a random number generator that is any kind of BaseDeviate
object. If <code class="docutils literal notranslate"><span class="pre">rng</span></code> is None, one will be automatically created from the
system. [default: None]</p></li>
<li><p><strong>npoints</strong> – Number of points DistDeviate should use for its internal interpolation
tables. [default: None, which uses the DistDeviate default]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.thin">
<code class="sig-name descname">thin</code><span class="sig-paren">(</span><em class="sig-param">rel_err=0.0001</em>, <em class="sig-param">trim_zeros=True</em>, <em class="sig-param">preserve_range=True</em>, <em class="sig-param">fast_search=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.thin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.thin" title="Permalink to this definition">¶</a></dt>
<dd><p>If the SED was initialized with a LookupTable or from a file (which internally creates a
LookupTable), then remove tabulated values while keeping the integral over the set of
tabulated values still accurate to <code class="docutils literal notranslate"><span class="pre">rel_err</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rel_err</strong> – The relative error allowed in the integral over the SED
[default: 1.e-4]</p></li>
<li><p><strong>trim_zeros</strong> – Remove redundant leading and trailing points where f=0?  (The last
leading point with f=0 and the first trailing point with f=0 will
be retained).  Note that if both trim_leading_zeros and
preserve_range are True, then the only the range of <code class="docutils literal notranslate"><span class="pre">x</span></code> <em>after</em>
zero trimming is preserved.  [default: True]</p></li>
<li><p><strong>preserve_range</strong> – Should the original range (<code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">red_limit</span></code>) of the
SED be preserved? (True) Or should the ends be trimmed to
include only the region where the integral is significant? (False)
[default: True]</p></li>
<li><p><strong>fast_search</strong> – If set to True, then the underlying algorithm will use a
relatively fast O(N) algorithm to select points to include in the
thinned approximation.  If set to False, then a slower O(N^2)
algorithm will be used.  We have found that the slower algorithm
tends to yield a thinned representation that retains fewer samples
while still meeting the relative error requirement.
[default: True]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the thinned SED.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.withFlux">
<code class="sig-name descname">withFlux</code><span class="sig-paren">(</span><em class="sig-param">target_flux</em>, <em class="sig-param">bandpass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.withFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.withFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new SED with flux through the Bandpass <code class="docutils literal notranslate"><span class="pre">bandpass</span></code> set to <code class="docutils literal notranslate"><span class="pre">target_flux</span></code>.  See
ChromaticObject docstring for information about how SED normalization affects
ChromaticObject normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_flux</strong> – The desired flux normalization of the SED.</p></li>
<li><p><strong>bandpass</strong> – A Bandpass object defining a filter bandpass.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new normalized SED.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.withFluxDensity">
<code class="sig-name descname">withFluxDensity</code><span class="sig-paren">(</span><em class="sig-param">target_flux_density</em>, <em class="sig-param">wavelength</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.withFluxDensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.withFluxDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new SED with flux density set to <code class="docutils literal notranslate"><span class="pre">target_flux_density</span></code> at wavelength
<code class="docutils literal notranslate"><span class="pre">wavelength</span></code>.  See ChromaticObject docstring for information about how SED normalization
affects ChromaticObject normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_flux_density</strong> – The target normalization in photons/nm/cm^2/s.</p></li>
<li><p><strong>wavelength</strong> – The wavelength, in nm, at which the flux density will be set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new normalized SED.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.SED.withMagnitude">
<code class="sig-name descname">withMagnitude</code><span class="sig-paren">(</span><em class="sig-param">target_magnitude</em>, <em class="sig-param">bandpass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/sed.html#SED.withMagnitude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.SED.withMagnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new SED with magnitude through <code class="docutils literal notranslate"><span class="pre">bandpass</span></code> set to <code class="docutils literal notranslate"><span class="pre">target_magnitude</span></code>.  Note
that this requires <code class="docutils literal notranslate"><span class="pre">bandpass</span></code> to have been assigned a zeropoint using
<a class="reference internal" href="#galsim.Bandpass.withZeropoint" title="galsim.Bandpass.withZeropoint"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Bandpass.withZeropoint</span></code></a>.  See ChromaticObject docstring for information about how SED
normalization affects ChromaticObject normalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_magnitude</strong> – The desired magnitude of the SED.</p></li>
<li><p><strong>bandpass</strong> – A Bandpass object defining a filter bandpass.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new normalized SED.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bandpass-filters">
<h2>Bandpass Filters<a class="headerlink" href="#bandpass-filters" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.Bandpass">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">Bandpass</code><span class="sig-paren">(</span><em class="sig-param">throughput</em>, <em class="sig-param">wave_type</em>, <em class="sig-param">blue_limit=None</em>, <em class="sig-param">red_limit=None</em>, <em class="sig-param">zeropoint=None</em>, <em class="sig-param">_wave_list=None</em>, <em class="sig-param">_tp=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bandpass.html#Bandpass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bandpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple bandpass object, which models the transmission fraction of incident light as a
function of wavelength, for either an entire optical path (e.g., atmosphere, reflecting and
refracting optics, filters, CCD quantum efficiency), or some intermediate piece thereof.
Bandpasses representing individual components may be combined through the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator to form
a new Bandpass object representing the composite optical path.</p>
<p>Bandpasses are callable, returning dimensionless throughput as a function of wavelength in nm.</p>
<p>Bandpasses are immutable; all transformative methods return <em>new</em> Bandpasses, and leave their
originating Bandpasses unaltered.</p>
<p>Bandpasses require <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">red_limit</span></code> attributes, which may either be explicitly set
at initialization, or are inferred from the initializing galsim.LookupTable or 2-column file.</p>
<p>Outside of the wavelength interval between <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">red_limit</span></code>, the throughput is
returned as zero, regardless of the <code class="docutils literal notranslate"><span class="pre">throughput</span></code> input parameter.</p>
<p>Bandpasses may be multiplied by other Bandpasses, functions, scalars, or SEDs.  The product of a
Bandpass with an SED is a new SED.</p>
<p>The Bandpass effective wavelength is stored in the python property <code class="docutils literal notranslate"><span class="pre">effective_wavelength</span></code>. We
use throughput-weighted average wavelength (which is independent of any SED) as our definition
for effective wavelength.</p>
<p>For Bandpasses defined using a LookupTable, a numpy.array of wavelengths, <code class="docutils literal notranslate"><span class="pre">wave_list</span></code>, defining
the table is maintained.  Bandpasses defined as products of two other Bandpasses will define
their <code class="docutils literal notranslate"><span class="pre">wave_list</span></code> as the union of multiplicand <code class="docutils literal notranslate"><span class="pre">wave_list</span></code> values, although limited to the
range between the new product <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">red_limit</span></code>.  (This implementation detail
may affect the choice of integrator used to draw ChromaticObjects.)</p>
<p>The input parameter, throughput, may be one of several possible forms:</p>
<ol class="arabic simple">
<li><p>a regular python function (or an object that acts like a function)</p></li>
<li><p>a galsim.LookupTable</p></li>
<li><p>a file from which a LookupTable can be read in</p></li>
<li><p>a string which can be evaluated into a function of <code class="docutils literal notranslate"><span class="pre">wave</span></code>
via <code class="docutils literal notranslate"><span class="pre">eval('lambda</span> <span class="pre">wave</span> <span class="pre">:</span> <span class="pre">'+throughput)</span></code>
e.g. throughput = ‘0.8 + 0.2 * (wave-800)’</p></li>
</ol>
<p>The argument of <code class="docutils literal notranslate"><span class="pre">throughput</span></code> will be the wavelength in units specified by <code class="docutils literal notranslate"><span class="pre">wave_type</span></code>. (See
below.) The output should be the dimensionless throughput at that wavelength.  (Note we use
<code class="docutils literal notranslate"><span class="pre">wave</span></code> rather than <code class="docutils literal notranslate"><span class="pre">lambda</span></code>, since <code class="docutils literal notranslate"><span class="pre">lambda</span></code> is a python reserved word.)</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">wave_type</span></code> specifies the units to assume for wavelength and must be one of
‘nm’, ‘nanometer’, ‘nanometers’, ‘A’, ‘Ang’, ‘Angstrom’, or ‘Angstroms’, or an astropy
distance unit.  (For the string values, case is unimportant.)  If given, blue_limit and
red_limit are taken to be in these units as well.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">wave_type</span></code> parameter does not propagate into other methods of <a class="reference internal" href="#galsim.Bandpass" title="galsim.Bandpass"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Bandpass</span></code></a>.
For instance, Bandpass.__call__ assumes its input argument is in nanometers.</p>
<p>Finally, a Bandpass may have zeropoint attribute, which is a float used to convert flux
(in photons/s/cm^2) to magnitudes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mag</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">log10</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">+</span> <span class="n">zeropoint</span>
</pre></div>
</div>
<p>You can either set the zeropoint at initialization, or via the <a class="reference internal" href="#galsim.Bandpass.withZeropoint" title="galsim.Bandpass.withZeropoint"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">withZeropoint</span></code></a> method.  Note
that the zeropoint attribute does not propagate if you get a new Bandpass by multiplying or
dividing an old Bandpass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>throughput</strong> – Function defining the throughput at each wavelength.  See above for
valid options for this parameter.</p></li>
<li><p><strong>wave_type</strong> – The units to use for the wavelength argument of the <code class="docutils literal notranslate"><span class="pre">throughput</span></code>
function. See above for details.</p></li>
<li><p><strong>blue_limit</strong> – Hard cut off of bandpass on the blue side. [default: None, but required
if throughput is not a LookupTable or file.  See above.]</p></li>
<li><p><strong>red_limit</strong> – Hard cut off of bandpass on the red side. [default: None, but required
if throughput is not a LookupTable or file.  See above.]</p></li>
<li><p><strong>zeropoint</strong> – Set the zero-point for this Bandpass.  Here, this can only be a float
value.  See the method <a class="reference internal" href="#galsim.Bandpass.withZeropoint" title="galsim.Bandpass.withZeropoint"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">withZeropoint</span></code></a> for other options for how to
set this using a particular spectrum (AB, Vega, etc.) [default: None]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.Bandpass.calculateEffectiveWavelength">
<code class="sig-name descname">calculateEffectiveWavelength</code><span class="sig-paren">(</span><em class="sig-param">precise=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bandpass.html#Bandpass.calculateEffectiveWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bandpass.calculateEffectiveWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate, store, and return the effective wavelength for this bandpass.  We define
the effective wavelength as the throughput-weighted average wavelength, which is
SED-independent.  Units are nanometers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>precise</strong> – Optionally use a more precise integration method when the bandpass uses
a LookupTable rather than the normal trapezoid rule. [default: False]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Bandpass.thin">
<code class="sig-name descname">thin</code><span class="sig-paren">(</span><em class="sig-param">rel_err=0.0001</em>, <em class="sig-param">trim_zeros=True</em>, <em class="sig-param">preserve_range=True</em>, <em class="sig-param">fast_search=True</em>, <em class="sig-param">preserve_zp=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bandpass.html#Bandpass.thin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bandpass.thin" title="Permalink to this definition">¶</a></dt>
<dd><p>Thin out the internal wavelengths of a Bandpass that uses a LookupTable.</p>
<p>If the bandpass was initialized with a LookupTable or from a file (which internally
creates a LookupTable), this function removes tabulated values while keeping the integral
over the set of tabulated values still accurate to the given relative error.</p>
<p>That is, the integral of the bandpass function is preserved to a relative precision
of <code class="docutils literal notranslate"><span class="pre">rel_err</span></code>, while eliminating as many internal wavelength values as possible.  This
process will usually help speed up integrations using this bandpass.  You should weigh
the speed improvements against your fidelity requirements for your particular use
case.</p>
<p>By default, this routine will preserve the zeropoint of the original bandpass by assigning
it to the new thinned bandpass.  The justification for this choice is that when using an AB
zeropoint, a typical optical bandpass, and the default thinning <code class="docutils literal notranslate"><span class="pre">rel_err</span></code> value, the
zeropoint for the new and thinned bandpasses changes by 10^-6.  However, if you are thinning
a lot, and/or want to do extremely precise tests, you can set <code class="docutils literal notranslate"><span class="pre">preserve_zp=False</span></code> and then
recalculate the zeropoint after thinning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rel_err</strong> – The relative error allowed in the integral over the throughput
function. [default: 1.e-4]</p></li>
<li><p><strong>trim_zeros</strong> – Remove redundant leading and trailing points where f=0?  (The last
leading point with f=0 and the first trailing point with f=0 will
be retained).  Note that if both trim_leading_zeros and
preserve_range are True, then the only the range of <code class="docutils literal notranslate"><span class="pre">x</span></code> <em>after</em>
zero trimming is preserved.  [default: True]</p></li>
<li><p><strong>preserve_range</strong> – Should the original range (<code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">red_limit</span></code>) of the
Bandpass be preserved? (True) Or should the ends be trimmed to
include only the region where the integral is significant? (False)
[default: True]</p></li>
<li><p><strong>fast_search</strong> – If set to True, then the underlying algorithm will use a
relatively fast O(N) algorithm to select points to include in the
thinned approximation.  If set to False, then a slower O(N^2)
algorithm will be used.  We have found that the slower algorithm
tends to yield a thinned representation that retains fewer samples
while still meeting the relative error requirement, and may also
be somewhat more robust when computing SED fluxes through
Bandpasses when a significant fraction of the integrated flux
passes through low throughput bandpass light leaks.
[default: True]</p></li>
<li><p><strong>preserve_zp</strong> – If True, the new thinned Bandpass will be assigned the same
zeropoint as the original.  If False, the new thinned Bandpass
will have a zeropoint of None. [default: True]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the thinned Bandpass.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Bandpass.truncate">
<code class="sig-name descname">truncate</code><span class="sig-paren">(</span><em class="sig-param">blue_limit=None</em>, <em class="sig-param">red_limit=None</em>, <em class="sig-param">relative_throughput=None</em>, <em class="sig-param">preserve_zp='auto'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bandpass.html#Bandpass.truncate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bandpass.truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a bandpass with its wavelength range truncated.</p>
<p>This function truncate the range of the bandpass either explicitly (with <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> or
<code class="docutils literal notranslate"><span class="pre">red_limit</span></code> or both) or automatically, just trimming off leading and trailing wavelength
ranges where the relative throughput is less than some amount (<code class="docutils literal notranslate"><span class="pre">relative_throughput</span></code>).</p>
<p>This second option using relative_throughput is only available for bandpasses initialized
with a LookupTable or from a file, not when using a regular python function or a string
evaluation.</p>
<p>This function does not remove any intermediate wavelength ranges, but see thin() for
a method that can thin out the intermediate values.</p>
<p>When truncating a bandpass that already has an assigned zeropoint, there are several
possibilities for what should happen to the new (returned) bandpass by default.  If red
and/or blue limits are given, then the new bandpass will have no assigned zeropoint because
it is difficult to predict what should happen if the bandpass is being arbitrarily
truncated.  If <code class="docutils literal notranslate"><span class="pre">relative_throughput</span></code> is given, often corresponding to low-level truncation
that results in little change in observed quantities, then the new bandpass is assigned the
same zeropoint as the original.  This default behavior is called ‘auto’.  The user can also
give boolean True or False values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>blue_limit</strong> – Truncate blue side of bandpass at this wavelength in nm.
[default: None]</p></li>
<li><p><strong>red_limit</strong> – Truncate red side of bandpass at this wavelength in nm.
[default: None]</p></li>
<li><p><strong>relative_throughput</strong> – Truncate leading or trailing wavelengths that are below
this relative throughput level.  (See above for details.)
Either <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and/or <code class="docutils literal notranslate"><span class="pre">red_limit</span></code> should be supplied,
or <code class="docutils literal notranslate"><span class="pre">relative_throughput</span></code> should be supplied – but
<code class="docutils literal notranslate"><span class="pre">relative_throughput</span></code> should not be combined with one of the
limits.
[default: None]</p></li>
<li><p><strong>preserve_zp</strong> – If True, the new truncated Bandpass will be assigned the same
zeropoint as the original.  If False, the new truncated Bandpass
will have a zeropoint of None. If ‘auto’, the new truncated
Bandpass will have the same zeropoint as the original when
truncating using <code class="docutils literal notranslate"><span class="pre">relative_throughput</span></code>, but will have a
zeropoint of None when truncating using ‘blue_limit’ and/or
‘red_limit’.  [default: ‘auto’]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the truncated Bandpass.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Bandpass.withZeropoint">
<code class="sig-name descname">withZeropoint</code><span class="sig-paren">(</span><em class="sig-param">zeropoint</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bandpass.html#Bandpass.withZeropoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bandpass.withZeropoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign a zeropoint to this Bandpass.</p>
<p>A bandpass zeropoint is a float used to convert flux (in photons/s/cm^2) to magnitudes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mag</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.5</span><span class="o">*</span><span class="n">log10</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span> <span class="o">+</span> <span class="n">zeropoint</span>
</pre></div>
</div>
<p>Note that the zeropoint attribute does not propagate if you get a new Bandpass by
multiplying or dividing an old Bandpass.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">zeropoint</span></code> argument can take a variety of possible forms:</p>
<ol class="arabic simple">
<li><p>a number, which will be the zeropoint</p></li>
<li><p>a galsim.SED.  In this case, the zeropoint is set such that the magnitude of the supplied
SED through the bandpass is 0.0</p></li>
<li><p>the string ‘AB’.  In this case, use an AB zeropoint.</p></li>
<li><p>the string ‘Vega’.  Use a Vega zeropoint.</p></li>
<li><p>the string ‘ST’.  Use a HST STmag zeropoint.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>zeropoint</strong> – See above for valid input options</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new Bandpass with zeropoint set.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="chromatic-profiles">
<h2>Chromatic Profiles<a class="headerlink" href="#chromatic-profiles" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.ChromaticObject">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticObject</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for defining wavelength-dependent objects.</p>
<p>This class primarily serves as the base class for chromatic subclasses.  See the docstrings for
subclasses for more details.</p>
<p>A ChromaticObject can be instantiated directly from an existing GSObject.  In this case, the
newly created ChromaticObject will act in nearly the same way as the original GSObject works,
except that it has access to the ChromaticObject transformation methods described below (e.g.,
expand(), dilate(), shift(), withFlux(), …)  These can all take functions as arguments to
describe wavelength-dependent transformations.  E.g.,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gsobj</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">fwhm</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chrom_obj</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ChromaticObject</span><span class="p">(</span><span class="n">gsobj</span><span class="p">)</span><span class="o">.</span><span class="n">dilate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">wave</span><span class="p">:</span> <span class="p">(</span><span class="n">wave</span><span class="o">/</span><span class="mf">500.</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2</span><span class="p">))</span>
</pre></div>
</div>
<p>In this and similar cases, the argument to the transformation method should be a python callable
that accepts wavelength in nanometers and returns whatever type the transformation method
normally accepts (so an int or float above).</p>
<p>One caveat to creating ChromaticObjects directly from GSObjects like this is that even though
the source GSObject instance has flux units in photons/s/cm^2, the newly formed ChromaticObject
will be interpreted as dimensionless, i.e., it will have a dimensionless SED (and have its
.dimensionless attribute set to True).  See below for more discussion about the dimensions of
ChromaticObjects.</p>
<p>Another way to instantiate a ChromaticObject from a GSObject is to multiply by an SED.  This can
be useful to consistently generate the same galaxy observed through different filters, or, with
ChromaticSum, to construct multi-component galaxies, each component with a different SED.  For
example, a bulge+disk galaxy could be constructed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bulge_SED</span> <span class="o">=</span> <span class="n">user_function_to_get_bulge_spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">disk_SED</span> <span class="o">=</span> <span class="n">user_function_to_get_disk_spectrum</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bulge_mono</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">DeVaucouleurs</span><span class="p">(</span><span class="n">half_light_radius</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">disk_mono</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Exponential</span><span class="p">(</span><span class="n">half_light_radius</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bulge</span> <span class="o">=</span> <span class="n">bulge_mono</span> <span class="o">*</span> <span class="n">bulge_SED</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">disk</span> <span class="o">=</span> <span class="n">disk_mono</span> <span class="o">*</span> <span class="n">disk_SED</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gal</span> <span class="o">=</span> <span class="n">bulge</span> <span class="o">+</span> <span class="n">disk</span>
</pre></div>
</div>
<p>The SEDs above describe the flux density in photons/nm/cm^2/s of an object, possibly normalized
with either the sed.withFlux(bandpass) or sed.withMagnitude(bandpass) methods (see the
docstrings in the SED class for details about these and other normalization options).  Note that
for dimensional consistency, in this case, the <code class="docutils literal notranslate"><span class="pre">flux</span></code> attribute of the multiplied GSObject is
interpreted as being dimensionless instead of in its normal units of [photons/s/cm^2].  The
photons/s/cm^2 units are (optionally) carried by the SED instead, or even left out entirely if
the SED is dimensionless itself (see discussion on ChromaticObject dimensions below).  The
GSObject <code class="docutils literal notranslate"><span class="pre">flux</span></code> attribute <em>does</em> still contribute to the ChromaticObject normalization,
though.  For example, the following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chrom_obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">sed</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">gsobj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chrom_obj2</span> <span class="o">=</span> <span class="n">sed</span> <span class="o">*</span> <span class="p">(</span><span class="n">gsobj</span> <span class="o">*</span> <span class="mf">3.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Subclasses that instantiate a ChromaticObject directly also exist, such as ChromaticAtmosphere.
Even in this case, however, the underlying implementation always eventually wraps one or more
GSObjects.</p>
<p>Dimensions:</p>
<p>ChromaticObjects can generally be sorted into two distinct types: those that represent galaxies
or stars and have dimensions of [photons/wavelength-interval/area/time/solid-angle], and those
that represent other types of wavelength dependence besides flux, like chromatic PSFs (these
have dimensions of [1/solid-angle]).  The former category of ChromaticObjects will have their
<code class="docutils literal notranslate"><span class="pre">.spectral</span></code> attribute set to True, while the latter category of ChromaticObjects will have their
<code class="docutils literal notranslate"><span class="pre">.dimensionless</span></code> attribute set to True.  These two classes of ChromaticObjects have different
restrictions associated with them.  For example, only spectral ChromaticObjects can be drawn
using chrom_obj.drawImage(bandpass, …), only ChromaticObjects of the same type can be added
together, and at most one spectral ChromaticObject can be part of a ChromaticConvolution.</p>
<p>Multiplying a dimensionless ChromaticObject a spectral SED produces a spectral ChromaticObject
(though note that the new object’s SED may not be equal to the SED being multiplied by since the
original ChromaticObject may not have had unit normalization.)</p>
<p>Methods:</p>
<p>gsobj = chrom_obj.evaluateAtWavelength(wave) returns the monochromatic surface brightness
profile (as a GSObject) at a given wavelength (in nanometers).</p>
<p>The interpolate() method can be used for non-separable ChromaticObjects to expedite the
image rendering process.  See the docstring of that method for more details and discussion of
when this is a useful tool (and the interplay between interpolation, object transformations, and
convolutions).</p>
<p>Also, ChromaticObject has most of the same methods as GSObjects with the following exceptions:</p>
<p>The GSObject access methods (e.g. xValue(), maxk, etc.) are not available.  Instead,
you would need to evaluate the profile at a particular wavelength and access what you want
from that.</p>
<p>The withFlux(), withFluxDensity, and withMagnitude() methods will return a new chromatic object
with the appropriate spatially integrated flux, flux density, or magnitude.</p>
<p>The drawImage() method draws the object as observed through a particular bandpass, so the
arguments are somewhat different.  See the docstring for ChromaticObject.drawImage() for more
details.</p>
<dl class="method">
<dt id="galsim.ChromaticObject.calculateCentroid">
<code class="sig-name descname">calculateCentroid</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.calculateCentroid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.calculateCentroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the centroid of the wavelength-integrated surface brightness profile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bandpass</strong> – The bandpass through which the observation is made.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the centroid of the integrated surface brightness profile, as a PositionD.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.calculateFlux">
<code class="sig-name descname">calculateFlux</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.calculateFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.calculateFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the flux (photons/cm^2/s) of the ChromaticObject through the bandpass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bandpass</strong> – A Bandpass object representing a filter, or None to compute the bolometric
flux.  For the bolometric flux the integration limits will be set to
(0, infinity) unless overridden by non-<code class="docutils literal notranslate"><span class="pre">None</span></code> SED attributes <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code>
or <code class="docutils literal notranslate"><span class="pre">red_limit</span></code>.  Note that SEDs defined using <a class="reference internal" href="table.html#galsim.LookupTable" title="galsim.LookupTable"><code class="xref any py py-class docutils literal notranslate"><span class="pre">LookupTable</span></code></a> automatically
have <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">red_limit</span></code> set.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the flux through the bandpass.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.calculateMagnitude">
<code class="sig-name descname">calculateMagnitude</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.calculateMagnitude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.calculateMagnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ChromaticObject magnitude through a Bandpass <code class="docutils literal notranslate"><span class="pre">bandpass</span></code>.  Note that this
requires <code class="docutils literal notranslate"><span class="pre">bandpass</span></code> to have been assigned a zeropoint using <a class="reference internal" href="#galsim.Bandpass.withZeropoint" title="galsim.Bandpass.withZeropoint"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Bandpass.withZeropoint</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bandpass</strong> – A Bandpass object representing a filter, or None to compute the
bolometric magnitude.  For the bolometric magnitude the integration
limits will be set to (0, infinity) unless overridden by non-<code class="docutils literal notranslate"><span class="pre">None</span></code> SED
attributes <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> or <code class="docutils literal notranslate"><span class="pre">red_limit</span></code>.  Note that SEDs defined using
<a class="reference internal" href="table.html#galsim.LookupTable" title="galsim.LookupTable"><code class="xref any py py-class docutils literal notranslate"><span class="pre">LookupTable</span></code></a> automatically have <code class="docutils literal notranslate"><span class="pre">blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">red_limit</span></code> set.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the bandpass magnitude.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.dilate">
<code class="sig-name descname">dilate</code><span class="sig-paren">(</span><em class="sig-param">scale</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.dilate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.dilate" title="Permalink to this definition">¶</a></dt>
<dd><p>Dilate the linear size of the profile by the given (possibly wavelength-dependent)
<code class="docutils literal notranslate"><span class="pre">scale</span></code>, while preserving flux.</p>
<p>e.g. <code class="docutils literal notranslate"><span class="pre">half_light_radius</span></code> &lt;– <code class="docutils literal notranslate"><span class="pre">half_light_radius</span> <span class="pre">*</span> <span class="pre">scale</span></code></p>
<p>See expand() and magnify() for versions that preserve surface brightness, and thus
change the flux.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scale</strong> – The linear rescaling factor to apply.  In addition, <code class="docutils literal notranslate"><span class="pre">scale</span></code> may be a
callable function, in which case the argument should be wavelength in
nanometers and the return value the scale for that wavelength.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the dilated object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.dimensionless">
<em class="property">property </em><code class="sig-name descname">dimensionless</code><a class="headerlink" href="#galsim.ChromaticObject.dimensionless" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean indicating if ChromaticObject is dimensionless.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.drawImage">
<code class="sig-name descname">drawImage</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em>, <em class="sig-param">image=None</em>, <em class="sig-param">integrator='trapezoidal'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.drawImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.drawImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation for drawing an image of a ChromaticObject.</p>
<p>Some subclasses may choose to override this for specific efficiency gains.  For instance,
most GalSim use cases will probably finish with a convolution, in which case
ChromaticConvolution.drawImage() will be used.</p>
<p>The task of drawImage() in a chromatic context is to integrate a chromatic surface
brightness profile multiplied by the throughput of <code class="docutils literal notranslate"><span class="pre">bandpass</span></code>, over the wavelength interval
indicated by <code class="docutils literal notranslate"><span class="pre">bandpass</span></code>.</p>
<p>Several integrators are available in galsim.integ to do this integration when using the
first method (non-interpolated integration).  By default,
<code class="docutils literal notranslate"><span class="pre">galsim.integ.SampleIntegrator(rule=galsim.integ.trapzRule)</span></code> will be used if either
<code class="docutils literal notranslate"><span class="pre">bandpass.wave_list</span></code> or <code class="docutils literal notranslate"><span class="pre">self.wave_list</span></code> have len() &gt; 0.  If lengths of both are zero, which
may happen if both the bandpass throughput and the SED associated with <code class="docutils literal notranslate"><span class="pre">self</span></code> are analytic
python functions, for example, then
<code class="docutils literal notranslate"><span class="pre">galsim.integ.ContinuousIntegrator(rule=galsim.integ.trapzRule)</span></code>
will be used instead.  This latter case by default will evaluate the integrand at 250
equally-spaced wavelengths between <code class="docutils literal notranslate"><span class="pre">bandpass.blue_limit</span></code> and <code class="docutils literal notranslate"><span class="pre">bandpass.red_limit</span></code>.</p>
<p>By default, the above two integrators will use the trapezoidal rule for integration.  The
midpoint rule for integration can be specified instead by passing an integrator that has
been initialized with the <code class="docutils literal notranslate"><span class="pre">rule=galsim.integ.midptRule</span></code> argument.  When creating a
ContinuousIntegrator, the number of samples <code class="docutils literal notranslate"><span class="pre">N</span></code> is also an argument.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">integrator</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ContinuousIntegrator</span><span class="p">(</span><span class="n">rule</span><span class="o">=</span><span class="n">galsim</span><span class="o">.</span><span class="n">integ</span><span class="o">.</span><span class="n">midptRule</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">chromatic_obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">bandpass</span><span class="p">,</span> <span class="n">integrator</span><span class="o">=</span><span class="n">integrator</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, this method uses a cache to avoid recomputing the integral over the product of
the bandpass and object SED when possible (i.e., for separable profiles).  Because the
cache size is finite, users may find that it is more efficient when drawing many images
to group images using the same SEDs and bandpasses together in order to hit the cache more
often.  The default cache size is 10, but may be resized using the
<a class="reference internal" href="#galsim.ChromaticObject.resize_multiplier_cache" title="galsim.ChromaticObject.resize_multiplier_cache"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">ChromaticObject.resize_multiplier_cache</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – A Bandpass object representing the filter against which to
integrate.</p></li>
<li><p><strong>image</strong> – Optionally, the Image to draw onto.  (See GSObject.drawImage()
for details.)  [default: None]</p></li>
<li><p><strong>integrator</strong> – When doing the exact evaluation of the profile, this argument should
be one of the image integrators from galsim.integ, or a string
‘trapezoidal’ or ‘midpoint’, in which case the routine will use a
SampleIntegrator or ContinuousIntegrator depending on whether or not
the object has a <code class="docutils literal notranslate"><span class="pre">wave_list</span></code>.  [default: ‘trapezoidal’,
which will try to select an appropriate integrator using the
trapezoidal integration rule automatically.]</p></li>
<li><p><strong>**kwargs</strong> – For all other kwarg options, see GSObject.drawImage()</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the drawn Image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.drawKImage">
<code class="sig-name descname">drawKImage</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em>, <em class="sig-param">image=None</em>, <em class="sig-param">integrator='trapezoidal'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.drawKImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.drawKImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation for drawing the Fourier transform of a ChromaticObject.</p>
<p>The task of drawKImage() in a chromatic context is exactly analogous to the task of
drawImage() in a chromatic context: to integrate the <code class="docutils literal notranslate"><span class="pre">SED</span> <span class="pre">*</span> <span class="pre">bandpass</span></code> weighted Fourier
profiles over wavelength.</p>
<p>See drawImage() for details on integration options.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – A Bandpass object representing the filter against which to integrate.</p></li>
<li><p><strong>image</strong> – If provided, this will be the ImageC onto which to draw the k-space
image.  If <code class="docutils literal notranslate"><span class="pre">image</span></code> is None, then an automatically-sized image will be
created.  If <code class="docutils literal notranslate"><span class="pre">image</span></code> is given, but its bounds are undefined, then it
will be resized appropriately based on the profile’s size.
[default: None]</p></li>
<li><p><strong>integrator</strong> – When doing the exact evaluation of the profile, this argument should be
one of the image integrators from galsim.integ, or a string
‘trapezoidal’ or ‘midpoint’, in which case the routine will use a
SampleIntegrator or ContinuousIntegrator depending on whether or not the
object has a <code class="docutils literal notranslate"><span class="pre">wave_list</span></code>.  [default: ‘trapezoidal’, which will try to
select an appropriate integrator using the trapezoidal integration rule
automatically.]</p></li>
<li><p><strong>**kwargs</strong> – For all other kwarg options, see GSObject.drawKImage()</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an ImageC instance (created if necessary)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this chromatic object at a particular wavelength.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.expand">
<code class="sig-name descname">expand</code><span class="sig-paren">(</span><em class="sig-param">scale</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the linear size of the profile by the given (possibly wavelength-dependent)
scale factor <code class="docutils literal notranslate"><span class="pre">scale</span></code>, while preserving surface brightness.</p>
<p>This doesn’t correspond to either of the normal operations one would typically want to
do to a galaxy.  The functions dilate() and magnify() are the more typical usage.  But this
function is conceptually simple.  It rescales the linear dimension of the profile, while
preserving surface brightness.  As a result, the flux will necessarily change as well.</p>
<p>See dilate() for a version that applies a linear scale factor while preserving flux.</p>
<p>See magnify() for a version that applies a scale factor to the area while preserving surface
brightness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scale</strong> – The factor by which to scale the linear dimension of the object.  In
addition, <code class="docutils literal notranslate"><span class="pre">scale</span></code> may be a callable function, in which case the argument
should be wavelength in nanometers and the return value the scale for that
wavelength.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the expanded object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.interpolate">
<code class="sig-name descname">interpolate</code><span class="sig-paren">(</span><em class="sig-param">waves</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is used as a pre-processing step that can expedite image rendering using objects
that have to be built up as sums of GSObjects with different parameters at each wavelength,
by interpolating between Images at each wavelength instead of making a more costly
instantiation of the relevant GSObject at each value of wavelength at which the bandpass is
defined.  This routine does a costly initialization process to build up a grid of images to
be used for the interpolation later on.  However, the object can get reused with different
bandpasses, so there should not be any need to make many versions of this object, and there
is a significant savings each time it is drawn into an image.  As a general rule of thumb,
chromatic objects that are separable do not benefit from this particular optimization,
whereas those that involve making GSObjects with wavelength-dependent keywords or
transformations do benefit from it.  Note that the interpolation scheme is simple linear
interpolation in wavelength, and no extrapolation beyond the originally-provided range of
wavelengths is permitted.  However, the overall flux at each wavelength will use the exact
SED at that wavelength to give more accurate final flux values.  You can disable this
feature by setting <code class="docutils literal notranslate"><span class="pre">use_exact_SED</span> <span class="pre">=</span> <span class="pre">False</span></code>.</p>
<p>The speedup involved in using interpolation depends in part on the bandpass used for
rendering (since that determines how many full profile evaluations are involved in rendering
the image).  However, for ChromaticAtmosphere with simple profiles like Kolmogorov, the
speedup in some simple example cases is roughly a factor of three, whereas for more
expensive to render profiles like the ChromaticOpticalPSF, the speedup is more typically a
factor of 10-50.</p>
<p>Achromatic transformations can be applied either before or after setting up interpolation,
with the best option depending on the application.  For example, when rendering many times
with the same achromatic transformation applied, it is typically advantageous to apply the
transformation before setting up the interpolation.  But there is no value in this when
applying different achromatic transformation to each object.  Chromatic transformations
should be applied before setting up interpolation; attempts to render images of
ChromaticObjects with interpolation followed by a chromatic transformation will result in
the interpolation being unset and the full calculation being done.</p>
<p>Because of the clever way that the ChromaticConvolution routine works, convolutions of
separable chromatic objects with non-separable ones that use interpolation will still
benefit from these optimizations.  For example, a non-separable chromatic PSF that uses
interpolation, when convolved with a sum of two separable galaxy components each with their
own SED, will be able to take advantage of this optimization.  In contrast, when convolving
two non-separable profiles that already have interpolation set up, there is no way to take
advantage of that interpolation optimization, so it will be ignored and the full calculation
will be done.  However, interpolation can be set up for the convolution of two non-separable
profiles, after the convolution step.  This could be beneficial for example when convolving
a chromatic optical PSF and chromatic atmosphere, before convolving with multiple galaxy
profiles.</p>
<p>For use cases requiring a high level of precision, we recommend a comparison between the
interpolated and the more accurate calculation for at least one case, to ensure that the
required precision has been reached.</p>
<p>The input parameter <code class="docutils literal notranslate"><span class="pre">waves</span></code> determines the input grid on which images are precomputed.  It
is difficult to give completely general guidance as to how many wavelengths to choose or how
they should be spaced; some experimentation compared with the exact calculation is warranted
for each particular application.  The best choice of settings might depend on how strongly
the parameters of the object depend on wavelength.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>waves</strong> – The list, tuple, or NumPy array of wavelengths to be used when
building up the grid of images for interpolation.  The wavelengths
should be given in nanometers, and they should span the full range
of wavelengths covered by any bandpass to be used for drawing Images
(i.e., this class will not extrapolate beyond the given range of
wavelengths).  They can be spaced any way the user likes, not
necessarily linearly, though interpolation will be linear in
wavelength between the specified wavelengths.</p></li>
<li><p><strong>oversample_fac</strong> – Factor by which to oversample the stored profiles compared to the
default, which is to sample them at the Nyquist frequency for
whichever wavelength has the highest Nyquist frequency.
<code class="docutils literal notranslate"><span class="pre">oversample_fac</span></code>&gt;1 results in higher accuracy but costlier
pre-computations (more memory and time). [default: 1]</p></li>
<li><p><strong>use_exact_SED</strong> – If true, then rescale the interpolated image for a given wavelength
by the ratio of the exact SED at that wavelength to the linearly
interpolated SED at that wavelength.  Thus, the flux of the
interpolated object should be correct, at the possible expense of
other features. [default: True]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the version of the Chromatic object that uses interpolation
(This will be an InterpolatedChromaticObject instance.)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.lens">
<code class="sig-name descname">lens</code><span class="sig-paren">(</span><em class="sig-param">g1</em>, <em class="sig-param">g2</em>, <em class="sig-param">mu</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.lens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.lens" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a lensing shear and magnification to this object.</p>
<p>This ChromaticObject method applies a lensing (reduced) shear and magnification.  The shear
must be specified using the g1, g2 definition of shear (see Shear documentation for more
details).  This is the same definition as the outputs of the PowerSpectrum and NFWHalo
classes, which compute shears according to some lensing power spectrum or lensing by an NFW
dark matter halo.  The magnification determines the rescaling factor for the object area and
flux, preserving surface brightness.</p>
<p>While gravitational lensing is achromatic, we do allow the parameters <code class="docutils literal notranslate"><span class="pre">g1</span></code>, <code class="docutils literal notranslate"><span class="pre">g2</span></code>, and <code class="docutils literal notranslate"><span class="pre">mu</span></code>
to be callable functions to be parallel to all the other transformations of chromatic
objects.  In this case, the functions should take the wavelength in nanometers as the
argument, and the return values are the corresponding value at that wavelength.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>g1</strong> – First component of lensing (reduced) shear to apply to the object.</p></li>
<li><p><strong>g2</strong> – Second component of lensing (reduced) shear to apply to the object.</p></li>
<li><p><strong>mu</strong> – Lensing magnification to apply to the object.  This is the factor by which
the solid angle subtended by the object is magnified, preserving surface
brightness.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the lensed object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.magnify">
<code class="sig-name descname">magnify</code><span class="sig-paren">(</span><em class="sig-param">mu</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.magnify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.magnify" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a lensing magnification, scaling the area and flux by <code class="docutils literal notranslate"><span class="pre">mu</span></code> at fixed surface
brightness.</p>
<p>This process applies a lensing magnification <code class="docutils literal notranslate"><span class="pre">mu</span></code>, which scales the linear dimensions of the
image by the factor sqrt(mu), i.e., <code class="docutils literal notranslate"><span class="pre">half_light_radius</span></code> &lt;– <code class="docutils literal notranslate"><span class="pre">half_light_radius</span> <span class="pre">*</span> <span class="pre">sqrt(mu)</span></code>
while increasing the flux by a factor of <code class="docutils literal notranslate"><span class="pre">mu</span></code>.  Thus, magnify() preserves surface
brightness.</p>
<p>See dilate() for a version that applies a linear scale factor while preserving flux.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mu</strong> – The lensing magnification to apply.  In addition, <code class="docutils literal notranslate"><span class="pre">mu</span></code> may be a callable
function, in which case the argument should be wavelength in nanometers
and the return value the magnification for that wavelength.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the magnified object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.resize_multiplier_cache">
<em class="property">static </em><code class="sig-name descname">resize_multiplier_cache</code><span class="sig-paren">(</span><em class="sig-param">maxsize</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.resize_multiplier_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.resize_multiplier_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize the cache (default size=10) containing the integral over the product of an SED
and a Bandpass, which is used by ChromaticObject.drawImage().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxsize</strong> – The new number of products to cache.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.rotate">
<code class="sig-name descname">rotate</code><span class="sig-paren">(</span><em class="sig-param">theta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate this object by an Angle <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>theta</strong> – Rotation angle (Angle object, +ve anticlockwise). In addition, <code class="docutils literal notranslate"><span class="pre">theta</span></code> may
be a callable function, in which case the argument should be wavelength in
nanometers and the return value the rotation angle for that wavelength,
returned as a galsim.Angle instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the rotated object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.shear">
<code class="sig-name descname">shear</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.shear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an area-preserving shear to this object, where arguments are either a Shear,
or arguments that will be used to initialize one.</p>
<p>For more details about the allowed keyword arguments, see the documentation for Shear
(for doxygen documentation, see galsim.shear.Shear).</p>
<p>The shear() method precisely preserves the area.  To include a lensing distortion with
the appropriate change in area, either use shear() with magnify(), or use lens(), which
combines both operations.</p>
<p>Note that, while gravitational shear is monochromatic, the shear method may be used for
many other use cases including some which may be wavelength-dependent, such as
intrinsic galaxy shape, telescope dilation, atmospheric PSF shape, etc.  Thus, the
shear argument is allowed to be a function of wavelength like other transformations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>shear</strong> – The shear to be applied. Or, as described above, you may instead supply
parameters to construct a Shear directly.  eg. <code class="docutils literal notranslate"><span class="pre">obj.shear(g1=g1,g2=g2)</span></code>.
In addition, the <code class="docutils literal notranslate"><span class="pre">shear</span></code> parameter may be a callable function, in which
case the argument should be wavelength in nanometers and the return value
the shear for that wavelength, returned as a galsim.Shear instance.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the sheared object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a (possibly wavelength-dependent) (dx, dy) shift to this chromatic object.</p>
<p>For a wavelength-independent shift, you may supply <code class="docutils literal notranslate"><span class="pre">dx,dy</span></code> as either two arguments, as a
tuple, or as a PositionD or PositionI object.</p>
<p>For a wavelength-dependent shift, you may supply two functions of wavelength in nanometers
which will be interpreted as <code class="docutils literal notranslate"><span class="pre">dx(wave)</span></code> and <code class="docutils literal notranslate"><span class="pre">dy(wave)</span></code>, or a single function of wavelength
in nanometers that returns either a 2-tuple, PositionD, or PositionI.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dx</strong> – Horizontal shift to apply (float or function).</p></li>
<li><p><strong>dy</strong> – Vertical shift to apply (float or function).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the shifted object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.spectral">
<em class="property">property </em><code class="sig-name descname">spectral</code><a class="headerlink" href="#galsim.ChromaticObject.spectral" title="Permalink to this definition">¶</a></dt>
<dd><p>Boolean indicating if ChromaticObject has units compatible with a spectral density.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.transform">
<code class="sig-name descname">transform</code><span class="sig-paren">(</span><em class="sig-param">dudx</em>, <em class="sig-param">dudy</em>, <em class="sig-param">dvdx</em>, <em class="sig-param">dvdy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation to this object defined by an arbitrary Jacobian matrix.</p>
<p>This works the same as GSObject.transform(), so see that method’s docstring for more
details.</p>
<p>As with the other more specific chromatic trasnformations, dudx, dudy, dvdx, and dvdy
may be callable functions, in which case the argument should be wavelength in nanometers
and the return value the appropriate value for that wavelength.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dudx</strong> – du/dx, where (x,y) are the current coords, and (u,v) are the new coords.</p></li>
<li><p><strong>dudy</strong> – du/dy, where (x,y) are the current coords, and (u,v) are the new coords.</p></li>
<li><p><strong>dvdx</strong> – dv/dx, where (x,y) are the current coords, and (u,v) are the new coords.</p></li>
<li><p><strong>dvdy</strong> – dv/dy, where (x,y) are the current coords, and (u,v) are the new coords.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the transformed object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.withFlux">
<code class="sig-name descname">withFlux</code><span class="sig-paren">(</span><em class="sig-param">target_flux</em>, <em class="sig-param">bandpass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.withFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.withFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new ChromaticObject with flux through the Bandpass <code class="docutils literal notranslate"><span class="pre">bandpass</span></code> set to
<code class="docutils literal notranslate"><span class="pre">target_flux</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_flux</strong> – The desired flux normalization of the ChromaticObject.</p></li>
<li><p><strong>bandpass</strong> – A Bandpass object defining a filter bandpass.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new normalized ChromaticObject.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.withFluxDensity">
<code class="sig-name descname">withFluxDensity</code><span class="sig-paren">(</span><em class="sig-param">target_flux_density</em>, <em class="sig-param">wavelength</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.withFluxDensity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.withFluxDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new ChromaticObject with flux density set to <code class="docutils literal notranslate"><span class="pre">target_flux_density</span></code> at
wavelength <code class="docutils literal notranslate"><span class="pre">wavelength</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_flux_density</strong> – The target normalization in photons/nm/cm^2/s.</p></li>
<li><p><strong>wavelength</strong> – The wavelength, in nm, at which the flux density will be set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new normalized SED.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.withMagnitude">
<code class="sig-name descname">withMagnitude</code><span class="sig-paren">(</span><em class="sig-param">target_magnitude</em>, <em class="sig-param">bandpass</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.withMagnitude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.withMagnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new ChromaticObject with magnitude through <code class="docutils literal notranslate"><span class="pre">bandpass</span></code> set to
<code class="docutils literal notranslate"><span class="pre">target_magnitude</span></code>.  Note that this requires <code class="docutils literal notranslate"><span class="pre">bandpass</span></code> to have been assigned a zeropoint
using <a class="reference internal" href="#galsim.Bandpass.withZeropoint" title="galsim.Bandpass.withZeropoint"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Bandpass.withZeropoint</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target_magnitude</strong> – The desired magnitude of the ChromaticObject.</p></li>
<li><p><strong>bandpass</strong> – A Bandpass object defining a filter bandpass.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the new normalized ChromaticObject.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticObject.withScaledFlux">
<code class="sig-name descname">withScaledFlux</code><span class="sig-paren">(</span><em class="sig-param">flux_ratio</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticObject.withScaledFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticObject.withScaledFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply the flux of the object by <code class="docutils literal notranslate"><span class="pre">flux_ratio</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>flux_ratio</strong> – The factor by which to scale the normalization of the object.
<code class="docutils literal notranslate"><span class="pre">flux_ratio</span></code> may be a float, univariate callable function, in which case
the argument should be wavelength in nanometers and return value the
flux ratio for that wavelength, or an SED.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new object with scaled flux.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticAtmosphere">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticAtmosphere</code><span class="sig-paren">(</span><em class="sig-param">base_obj</em>, <em class="sig-param">base_wavelength</em>, <em class="sig-param">scale_unit=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAtmosphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAtmosphere" title="Permalink to this definition">¶</a></dt>
<dd><p>A ChromaticObject implementing two atmospheric chromatic effects: differential
chromatic refraction (DCR) and wavelength-dependent seeing.</p>
<p>Due to DCR, blue photons land closer to the zenith than red photons.  Kolmogorov turbulence
also predicts that blue photons get spread out more by the atmosphere than red photons,
specifically FWHM is proportional to wavelength^(-0.2).  Both of these effects can be
implemented by wavelength-dependent shifts and dilations.</p>
<p>Since DCR depends on the zenith angle and the parallactic angle (which is the position angle of
the zenith measured from North through East) of the object being drawn, these must be specified
via keywords.  There are four ways to specify these values:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>explicitly provide <code class="docutils literal notranslate"><span class="pre">zenith_angle</span> <span class="pre">=</span> <span class="pre">...</span></code> as a keyword of type Angle, and
<code class="docutils literal notranslate"><span class="pre">parallactic_angle</span></code> will be assumed to be 0 by default.</p></li>
<li><p>explicitly provide both <code class="docutils literal notranslate"><span class="pre">zenith_angle</span> <span class="pre">=</span> <span class="pre">...</span></code> and <code class="docutils literal notranslate"><span class="pre">parallactic_angle</span> <span class="pre">=</span> <span class="pre">...</span></code> as
keywords of type Angle.</p></li>
<li><p>provide the coordinates of the object <code class="docutils literal notranslate"><span class="pre">obj_coord</span> <span class="pre">=</span> <span class="pre">...</span></code> and the coordinates of the zenith
<code class="docutils literal notranslate"><span class="pre">zenith_coord</span> <span class="pre">=</span> <span class="pre">...</span></code> as keywords of type CelestialCoord.</p></li>
<li><p>provide the coordinates of the object <code class="docutils literal notranslate"><span class="pre">obj_coord</span> <span class="pre">=</span> <span class="pre">...</span></code> as a CelestialCoord, the
hour angle of the object <code class="docutils literal notranslate"><span class="pre">HA</span> <span class="pre">=</span> <span class="pre">...</span></code> as an Angle, and the latitude of the observer
<code class="docutils literal notranslate"><span class="pre">latitude</span> <span class="pre">=</span> <span class="pre">...</span></code> as an Angle.</p></li>
</ol>
</div></blockquote>
<p>DCR also depends on temperature, pressure and water vapor pressure of the atmosphere.  The
default values for these are expected to be appropriate for LSST at Cerro Pachon, Chile, but
they are broadly reasonable for most observatories.</p>
<p>Note that a ChromaticAtmosphere by itself is NOT the correct thing to use to draw an image of a
star. Stars (and galaxies too, of course) have an SED that is not flat. To draw a real star, you
should either multiply the ChromaticAtmosphere object by an SED, or convolve it with a point
source multiplied by an SED:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ChromaticAtmosphere</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">star</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">DeltaFunction</span><span class="p">()</span> <span class="o">*</span> <span class="n">psf_sed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">final_star</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Convolve</span><span class="p">(</span> <span class="p">[</span><span class="n">psf</span><span class="p">,</span> <span class="n">star</span><span class="p">]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">final_star</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">bandpass</span> <span class="o">=</span> <span class="n">bp</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>base_obj</strong> – Fiducial PSF, equal to the monochromatic PSF at <code class="docutils literal notranslate"><span class="pre">base_wavelength</span></code></p></li>
<li><p><strong>base_wavelength</strong> – Wavelength represented by the fiducial PSF, in nanometers.</p></li>
<li><p><strong>scale_unit</strong> – Units used by base_obj for its linear dimensions.
[default: galsim.arcsec]</p></li>
<li><p><strong>alpha</strong> – Power law index for wavelength-dependent seeing.  [default: -0.2,
the prediction for Kolmogorov turbulence]</p></li>
<li><p><strong>zenith_angle</strong> – Angle from object to zenith, expressed as an Angle
[default: 0]</p></li>
<li><p><strong>parallactic_angle</strong> – Parallactic angle, i.e. the position angle of the zenith, measured
from North through East.  [default: 0]</p></li>
<li><p><strong>obj_coord</strong> – Celestial coordinates of the object being drawn as a
CelestialCoord. [default: None]</p></li>
<li><p><strong>zenith_coord</strong> – Celestial coordinates of the zenith as a CelestialCoord.
[default: None]</p></li>
<li><p><strong>HA</strong> – Hour angle of the object as an Angle. [default: None]</p></li>
<li><p><strong>latitude</strong> – Latitude of the observer as an Angle. [default: None]</p></li>
<li><p><strong>pressure</strong> – Air pressure in kiloPascals.  [default: 69.328 kPa]</p></li>
<li><p><strong>temperature</strong> – Temperature in Kelvins.  [default: 293.15 K]</p></li>
<li><p><strong>H2O_pressure</strong> – Water vapor pressure in kiloPascals.  [default: 1.067 kPa]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticAtmosphere.build_obj">
<code class="sig-name descname">build_obj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAtmosphere.build_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAtmosphere.build_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a ChromaticTransformation object for this ChromaticAtmosphere.</p>
<p>We don’t do this right away to help make ChromaticAtmosphere objects be picklable.
Building this is quite fast, so we do it on the fly in evaluateAtWavelength and
drawImage.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticAtmosphere.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAtmosphere.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAtmosphere.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this chromatic object at a particular wavelength.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticAtmosphere.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAtmosphere.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAtmosphere.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticOpticalPSF">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticOpticalPSF</code><span class="sig-paren">(</span><em class="sig-param">lam</em>, <em class="sig-param">diam=None</em>, <em class="sig-param">lam_over_diam=None</em>, <em class="sig-param">aberrations=None</em>, <em class="sig-param">scale_unit=None</em>, <em class="sig-param">gsparams=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticOpticalPSF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticOpticalPSF" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of ChromaticObject meant to represent chromatic optical PSFs.</p>
<p>Chromaticity plays two roles in optical PSFs. First, it determines the diffraction limit, via
the wavelength/diameter factor.  Second, aberrations such as defocus, coma, etc. are typically
defined in physical distances, but their impact on the PSF depends on their size in units of
wavelength.  Other aspects of the optical PSF do not require explicit specification of their
chromaticity, e.g., once the obscuration and struts are specified in units of the aperture
diameter, their chromatic dependence gets taken care of automatically.  Note that the
ChromaticOpticalPSF implicitly defines diffraction limits in units of <code class="docutils literal notranslate"><span class="pre">scale_units</span></code>, which by
default are arcsec, but can in principle be set to any of our GalSim angle units.</p>
<p>When using interpolation to speed up image rendering (see ChromaticObject.interpolate()
method for details), the ideal number of wavelengths to use across a given bandpass depends on
the application and accuracy requirements.  In general it will be necessary to do a test in
comparison with a more exact calculation to ensure convergence.  However, a typical calculation
might use ~10-15 samples across a typical optical bandpass, with <code class="docutils literal notranslate"><span class="pre">oversample_fac</span></code> in the range
1.5-2; for moderate accuracy, ~5 samples across the bandpass and <code class="docutils literal notranslate"><span class="pre">oversample_fac=1</span></code> may
suffice. All of these statements assume that aberrations are not very large (typically &lt;~0.25
waves, which is commonly satisfied by space telescopes); if they are larger than that, then more
stringent settings are required.</p>
<p>Note that a ChromaticOpticalPSF by itself is NOT the correct thing to use to draw an image of a
star. Stars (and galaxies too, of course) have an SED that is not flat. To draw a real star, you
should either multiply the ChromaticOpticalPSF object by an SED, or convolve it with a point
source multiplied by an SED:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ChromaticOpticalPSF</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">star</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">DeltaFunction</span><span class="p">()</span> <span class="o">*</span> <span class="n">psf_sed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">final_star</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Convolve</span><span class="p">(</span> <span class="p">[</span><span class="n">psf</span><span class="p">,</span> <span class="n">star</span><span class="p">]</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">final_star</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">bandpass</span> <span class="o">=</span> <span class="n">bp</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lam</strong> – Fiducial wavelength for which diffraction limit and aberrations are
initially defined, in nanometers.</p></li>
<li><p><strong>diam</strong> – Telescope diameter in meters.  Either <code class="docutils literal notranslate"><span class="pre">diam</span></code> or <code class="docutils literal notranslate"><span class="pre">lam_over_diam</span></code> must be
specified.</p></li>
<li><p><strong>lam_over_diam</strong> – Ratio of (fiducial wavelength) / telescope diameter in units of
<code class="docutils literal notranslate"><span class="pre">scale_unit</span></code>.  Either <code class="docutils literal notranslate"><span class="pre">diam</span></code> or <code class="docutils literal notranslate"><span class="pre">lam_over_diam</span></code> must be specified.</p></li>
<li><p><strong>aberrations</strong> – An array of aberrations, in units of fiducial wavelength <code class="docutils literal notranslate"><span class="pre">lam</span></code>.  The
size and format of this array is described in the OpticalPSF docstring.</p></li>
<li><p><strong>scale_unit</strong> – Units used to define the diffraction limit and draw images.
[default: galsim.arcsec]</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>**kwargs</strong> – Any other keyword arguments to be passed to OpticalPSF, for example,
related to struts, obscuration, oversampling, etc.  See OpticalPSF
docstring for a complete list of options.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticOpticalPSF.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticOpticalPSF.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticOpticalPSF.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to directly instantiate a monochromatic instance of this object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticOpticalPSF.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticOpticalPSF.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticOpticalPSF.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticAiry">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticAiry</code><span class="sig-paren">(</span><em class="sig-param">lam</em>, <em class="sig-param">diam=None</em>, <em class="sig-param">lam_over_diam=None</em>, <em class="sig-param">scale_unit=None</em>, <em class="sig-param">gsparams=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAiry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAiry" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of ChromaticObject meant to represent chromatic Airy profiles.</p>
<p>For more information about the basics of Airy profiles, please see help(galsim.Airy).</p>
<p>This class is a chromatic representation of Airy profiles, including the wavelength-dependent
diffraction limit.  One can also get this functionality using the ChromaticOpticalPSF class, but
that class includes additional complications beyond a simple Airy profile, and thus has a more
complicated internal representation.  For users who only want a (possibly obscured) Airy
profile, the ChromaticAiry class is likely to be a less computationally expensive and more
accurate option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lam</strong> – Fiducial wavelength for which diffraction limit is initially defined, in
nanometers.</p></li>
<li><p><strong>diam</strong> – Telescope diameter in meters.  Either <code class="docutils literal notranslate"><span class="pre">diam</span></code> or <code class="docutils literal notranslate"><span class="pre">lam_over_diam</span></code> must be
specified.</p></li>
<li><p><strong>lam_over_diam</strong> – Ratio of (fiducial wavelength) / telescope diameter in units of
<code class="docutils literal notranslate"><span class="pre">scale_unit</span></code>.  Either <code class="docutils literal notranslate"><span class="pre">diam</span></code> or <code class="docutils literal notranslate"><span class="pre">lam_over_diam</span></code> must be specified.</p></li>
<li><p><strong>scale_unit</strong> – Units used to define the diffraction limit and draw images.
[default: galsim.arcsec]</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>**kwargs</strong> – Any other keyword arguments to be passed to Airy: either flux, or
gsparams.  See galsim.Airy docstring for a complete description of these
options.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticAiry.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAiry.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAiry.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to directly instantiate a monochromatic instance of this object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticAiry.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAiry.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAiry.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticRealGalaxy">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticRealGalaxy</code><span class="sig-paren">(</span><em class="sig-param">real_galaxy_catalogs</em>, <em class="sig-param">index=None</em>, <em class="sig-param">id=None</em>, <em class="sig-param">random=False</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">gsparams=None</em>, <em class="sig-param">logger=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/real.html#ChromaticRealGalaxy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticRealGalaxy" title="Permalink to this definition">¶</a></dt>
<dd><p>A class describing real galaxies over multiple wavelengths, using some multi-band training
dataset.  The underlying implementation models multi-band images of individual galaxies
as chromatic PSF convolutions (and integrations over wavelength) with a sum of profiles
separable into spatial and spectral components.  The spectral components are specified by the
user, and the spatial components are determined one Fourier mode at a time by the class.  This
decomposition can be thought of as a constrained chromatic deconvolution of the multi-band
images by the associated PSFs, similar in spirit to RealGalaxy.</p>
<p>Because ChromaticRealGalaxy involves an InterpolatedKImage, <code class="docutils literal notranslate"><span class="pre">method</span> <span class="pre">=</span> <span class="pre">'phot'</span></code> is unavailable
for the drawImage() function.</p>
<p>Fundamentally, the required inputs for this class are (1) a series of high resolution input
Images of a single galaxy in different bands, (2) the Bandpasses corresponding to those
images, (3) the PSFs of those images as either GSObjects or ChromaticObjects, and (4)
the noise properties of the input images as instances of either <code class="docutils literal notranslate"><span class="pre">CorrelatedNoise</span></code> or
<code class="docutils literal notranslate"><span class="pre">UncorrelatedNoise</span></code>.  If you want to specify these inputs directly, that is possible via
the <code class="docutils literal notranslate"><span class="pre">.makeFromImages</span></code> factory method of this class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">crg</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ChromaticRealGalaxy</span><span class="o">.</span><span class="n">makeFromImages</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">PSFs</span><span class="p">,</span> <span class="n">xis</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, you may create a ChromaticRealGalaxy via a list of RealGalaxyCatalogs that
correspond to a set of galaxies observed in different bands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">crg</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ChromaticRealGalaxy</span><span class="p">(</span><span class="n">real_galaxy_catalogs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The above will use the 1st object in the catalogs, which should be the same galaxy, just
observed in different bands.  Note that there are multiple keywords for choosing a galaxy from
a catalog; exactly one must be set.  In the future we may add more such options, e.g., to
choose at random but accounting for the non-constant weight factors (probabilities for
objects to make it into the training sample).</p>
<p>The flux normalization of the returned object will by default match the original data, scaled to
correspond to a 1 second HST exposure (though see the <code class="docutils literal notranslate"><span class="pre">area_norm</span></code> parameter).  If you want
a flux appropriate for a longer exposure or telescope with different collecting area, you can
use the <code class="docutils literal notranslate"><span class="pre">ChromaticObject</span></code> method <code class="docutils literal notranslate"><span class="pre">withScaledFlux</span></code> on the returned object, or use the
<code class="docutils literal notranslate"><span class="pre">exptime</span></code> and <code class="docutils literal notranslate"><span class="pre">area</span></code> keywords to <code class="docutils literal notranslate"><span class="pre">drawImage</span></code>.  Note that while you can also use the
<code class="docutils literal notranslate"><span class="pre">ChromaticObject</span></code> methods <code class="docutils literal notranslate"><span class="pre">withFlux</span></code>, <code class="docutils literal notranslate"><span class="pre">withMagnitude</span></code>, and <code class="docutils literal notranslate"><span class="pre">withFluxDensity</span></code> to set the
absolute normalization, these methods technically adjust the flux of the entire postage stamp
image (including noise!) and not necessarily the flux of the galaxy itself.  (These two fluxes
will be strongly correlated for high signal-to-noise ratio galaxies, but may be considerably
different at low signal-to-noise ratio.)</p>
<p>Note that ChromaticRealGalaxy objects use arcsec for the units of their linear dimension.  If
you are using a different unit for other things (the PSF, WCS, etc.), then you should dilate the
resulting object with <code class="docutils literal notranslate"><span class="pre">gal.dilate(galsim.arcsec</span> <span class="pre">/</span> <span class="pre">scale_unit)</span></code>.</p>
<p>Noise from the original images is propagated by this class, though certain restrictions apply
to when and how that noise is made available.  The propagated noise depends on which Bandpass
the ChromaticRealGalaxy is being imaged through, so the noise is only available after
the <code class="docutils literal notranslate"><span class="pre">drawImage(bandpass,</span> <span class="pre">...)</span></code> method has been called.  Also, since ChromaticRealGalaxy will
only produce reasonable images when convolved with a (suitably wide) PSF, the noise attribute is
attached to the <code class="docutils literal notranslate"><span class="pre">ChromaticConvolution</span></code> (or <code class="docutils literal notranslate"><span class="pre">ChromaticTransformation</span></code> of the
<code class="docutils literal notranslate"><span class="pre">ChromaticConvolution</span></code>) which holds as one of its convolutants the <code class="docutils literal notranslate"><span class="pre">ChromaticRealGalaxy</span></code>.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">crg</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ChromaticRealGalaxy</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Convolve</span><span class="p">(</span><span class="n">crg</span><span class="p">,</span> <span class="n">psf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bandpass</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Bandpass</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;noise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">bandpass</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;noise&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noise1</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">noise</span>
</pre></div>
</div>
<p>Note that the noise attribute is only associated with the most recently used bandpass.  If you
draw another image of the same object using a different bandpass, the noise object will be
replaced.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bandpass2</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Bandpass</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image2</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">bandpass2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">noise1</span> <span class="o">!=</span> <span class="n">obj</span><span class="o">.</span><span class="n">noise</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>real_galaxy_catalogs</strong> – A list of <code class="docutils literal notranslate"><span class="pre">RealGalaxyCatalog</span></code> objects from which to create
<code class="docutils literal notranslate"><span class="pre">ChromaticRealGalaxy</span></code> objects.  Each catalog should represent the
same set of galaxies, and in the same order, just imaged through
different filters.  Note that the number of catalogs must be equal
to or larger than the number of SEDs.</p></li>
<li><p><strong>index</strong> – Index of the desired galaxy in the catalog. [One of <code class="docutils literal notranslate"><span class="pre">index</span></code>,
<code class="docutils literal notranslate"><span class="pre">id</span></code>, or <code class="docutils literal notranslate"><span class="pre">random</span></code> is required.]</p></li>
<li><p><strong>id</strong> – Object ID for the desired galaxy in the catalog. [One of <code class="docutils literal notranslate"><span class="pre">index</span></code>,
<code class="docutils literal notranslate"><span class="pre">id</span></code>, or <code class="docutils literal notranslate"><span class="pre">random</span></code> is required.]</p></li>
<li><p><strong>random</strong> – If True, then just select a completely random galaxy from the
catalog.  [One of <code class="docutils literal notranslate"><span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">id</span></code>, or <code class="docutils literal notranslate"><span class="pre">random</span></code> is required.]</p></li>
<li><p><strong>rng</strong> – A random number generator to use for selecting a random galaxy (may
be any kind of BaseDeviate or None) and to use in generating any
noise field when padding.  This user-input random number generator
takes precedence over any stored within a user-input CorrelatedNoise
instance (see <code class="docutils literal notranslate"><span class="pre">noise_pad</span></code> parameter below).  [default: None]</p></li>
<li><p><strong>SEDs</strong> – An optional list of <code class="docutils literal notranslate"><span class="pre">SED</span></code> to use when representing real galaxies
as sums of separable profiles. By default, len(real_galaxy_catalogs)
SEDs that are polynomials in wavelength will be used.  Note that the
number of SEDs must be equal to or smaller than the number of
catalogs.  [default: see above]</p></li>
<li><p><strong>k_interpolant</strong> – Either an Interpolant instance or a string indicating which k-space
interpolant should be used.  Options are ‘nearest’, ‘sinc’,
‘linear’, ‘cubic’, ‘quintic’, or ‘lanczosN’ where N should be the
integer order to use.  We strongly recommend leaving this parameter
at its default value; see text above for details.
[default: galsim.Quintic()]</p></li>
<li><p><strong>maxk</strong> – Optional maxk argument.  If you know you will be convolving the
resulting <code class="docutils literal notranslate"><span class="pre">ChromaticRealGalaxy</span></code> with a “fat” PSF in a subsequent
step, then it can be more efficient to limit the range of Fourier
modes used when solving for the sum of separable profiles below.
[default: None]</p></li>
<li><p><strong>pad_factor</strong> – Factor by which to internally oversample the Fourier-space images
that represent the ChromaticRealGalaxy (equivalent to zero-padding
the real-space profiles).  We strongly recommend leaving this
parameter at its default value; see text in Realgalaxy docstring
for details.  [default: 4]</p></li>
<li><p><strong>noise_pad_size</strong> – If provided, the image will be padded out to this size (in arcsec)
with the noise specified in the real galaxy catalog. This is
important if you are planning to whiten the resulting image.  You
should make sure that the padded image is larger than the postage
stamp onto which you are drawing this object.
[default: None]</p></li>
<li><p><strong>area_norm</strong> – Area in cm^2 by which to normalize the flux of the returned object.
When area_norm=1 (the default), drawing with <code class="docutils literal notranslate"><span class="pre">drawImage</span></code> keywords
exptime=1 and area=1 will simulate an image with the appropriate
number of counts for a 1 second exposure with the original
telescope/camera (e.g., with HST when using the COSMOS catalog).
If you would rather explicitly specify the collecting area of the
telescope when using <code class="docutils literal notranslate"><span class="pre">drawImage</span></code> with a <code class="docutils literal notranslate"><span class="pre">ChromaticRealGalaxy</span></code>,
then you should set area_norm equal to the collecting area of the
source catalog telescope when creating the <code class="docutils literal notranslate"><span class="pre">ChromaticRealGalaxy</span></code>
(e.g., area_norm=45238.93416 for HST). [default: 1]</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>logger</strong> – A logger object for output of progress statements if the user wants
them.  [default: None]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticRealGalaxy.makeFromImages">
<em class="property">classmethod </em><code class="sig-name descname">makeFromImages</code><span class="sig-paren">(</span><em class="sig-param">images</em>, <em class="sig-param">bands</em>, <em class="sig-param">PSFs</em>, <em class="sig-param">xis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/real.html#ChromaticRealGalaxy.makeFromImages"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticRealGalaxy.makeFromImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a ChromaticRealGalaxy directly from images, bandpasses, PSFs, and noise
descriptions.  See the ChromaticRealGalaxy docstring for more information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>images</strong> – An iterable of high resolution <code class="docutils literal notranslate"><span class="pre">Images</span></code> of a galaxy through
different bandpasses.</p></li>
<li><p><strong>bands</strong> – An iterable of <code class="docutils literal notranslate"><span class="pre">Bandpass</span></code> objects corresponding to the  input
images.</p></li>
<li><p><strong>PSFs</strong> – Either an iterable of <code class="docutils literal notranslate"><span class="pre">GSObject</span></code> or <code class="docutils literal notranslate"><span class="pre">ChromaticObject</span></code>
indicating the PSFs of the different input images, or potentially a
single <code class="docutils literal notranslate"><span class="pre">GSObject</span></code> or <code class="docutils literal notranslate"><span class="pre">ChromaticObject</span></code> that will be used as the
PSF for all images.</p></li>
<li><p><strong>xis</strong> – An iterable of either <code class="docutils literal notranslate"><span class="pre">CorrelatedNoise</span></code> or <code class="docutils literal notranslate"><span class="pre">UncorrelatedNoise</span></code>
objects characterizing the noise in the input images.</p></li>
<li><p><strong>SEDs</strong> – An optional list of <code class="docutils literal notranslate"><span class="pre">SED</span></code> to use when representing real galaxies
as sums of separable profiles.  By default, len(images) SEDs that
are polynomials in wavelength will be used.  Note that the number
of SEDs must be equal to or smaller than the number of catalogs.
[default: see above]</p></li>
<li><p><strong>k_interpolant</strong> – Either an Interpolant instance or a string indicating which k-space
interpolant should be used.  Options are ‘nearest’, ‘sinc’,
‘linear’, ‘cubic’, ‘quintic’, or ‘lanczosN’ where N should be the
integer order to use.  We strongly recommend leaving this parameter
at its default value; see text above for details.  [default:
galsim.Quintic()]</p></li>
<li><p><strong>maxk</strong> – Optional maxk argument.  If you know you will be convolving the
resulting <code class="docutils literal notranslate"><span class="pre">ChromaticRealGalaxy</span></code> with a “fat” PSF in a subsequent
step, then it can be more efficient to limit the range of Fourier
modes used when solving for the sum of separable profiles below.
[default: None]</p></li>
<li><p><strong>pad_factor</strong> – Factor by which to internally oversample the Fourier-space images
that represent the ChromaticRealGalaxy (equivalent to zero-padding
the real-space profiles).  We strongly recommend leaving this
parameter at its default value; see text in Realgalaxy docstring
for details.  [default: 4]</p></li>
<li><p><strong>noise_pad_size</strong> – If provided, the image will be padded out to this size (in arcsec)
with the noise specified in the real galaxy catalog. This is
important if you are planning to whiten the resulting image.  You
should make sure that the padded image is larger than the postage
stamp onto which you are drawing this object.
[default: None]</p></li>
<li><p><strong>area_norm</strong> – Area in cm^2 by which to normalize the flux of the returned object.
When area_norm=1 (the default), drawing with <code class="docutils literal notranslate"><span class="pre">drawImage</span></code> keywords
exptime=1 and area=1 will simulate an image with the appropriate
number of counts for a 1 second exposure with the original
telescope/camera (e.g., with HST when using the COSMOS catalog).  If
you would rather explicitly specify the collecting area of the
telescope when using <code class="docutils literal notranslate"><span class="pre">drawImage</span></code> with a <code class="docutils literal notranslate"><span class="pre">ChromaticRealGalaxy</span></code>,
then you should set area_norm equal to the collecting area of the
source catalog telescope when creating the <code class="docutils literal notranslate"><span class="pre">ChromaticRealGalaxy</span></code>
(e.g., area_norm=45238.93416 for HST). [default: 1]</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>logger</strong> – A logger object for output of progress statements if the user wants
them.  [default: None]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.InterpolatedChromaticObject">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">InterpolatedChromaticObject</code><span class="sig-paren">(</span><em class="sig-param">original</em>, <em class="sig-param">waves</em>, <em class="sig-param">oversample_fac=1.0</em>, <em class="sig-param">use_exact_SED=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#InterpolatedChromaticObject"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.InterpolatedChromaticObject" title="Permalink to this definition">¶</a></dt>
<dd><p>A ChromaticObject that uses interpolation of predrawn images to speed up subsequent
rendering.</p>
<p>This class wraps another ChromaticObject, which is stored in the attribute <code class="docutils literal notranslate"><span class="pre">deinterpolated</span></code>.
Any ChromaticObject can be used, although the interpolation procedure is most effective
for non-separable objects, which can sometimes be very slow to render.</p>
<p>Normally, you would not create an InterpolatedChromaticObject directly.  It is the
return type from <code class="docutils literal notranslate"><span class="pre">chrom_obj.interpolate()</span></code>.  See the description of that function
for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>original</strong> – The ChromaticObject to be interpolated.</p></li>
<li><p><strong>waves</strong> – The list, tuple, or NumPy array of wavelengths to be used when
building up the grid of images for interpolation.  The wavelengths
should be given in nanometers, and they should span the full range
of wavelengths covered by any bandpass to be used for drawing Images
(i.e., this class will not extrapolate beyond the given range of
wavelengths).  They can be spaced any way the user likes, not
necessarily linearly, though interpolation will be linear in
wavelength between the specified wavelengths.</p></li>
<li><p><strong>oversample_fac</strong> – Factor by which to oversample the stored profiles compared to the
default, which is to sample them at the Nyquist frequency for
whichever wavelength has the highest Nyquist frequency.
<code class="docutils literal notranslate"><span class="pre">oversample_fac</span></code>&gt;1 results in higher accuracy but costlier
pre-computations (more memory and time). [default: 1]</p></li>
<li><p><strong>use_exact_SED</strong> – If true, then rescale the interpolated image for a given wavelength by
the ratio of the exact SED at that wavelength to the linearly
interpolated SED at that wavelength.  Thus, the flux of the interpolated
object should be correct, at the possible expense of other features.
[default: True]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.InterpolatedChromaticObject.drawImage">
<code class="sig-name descname">drawImage</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em>, <em class="sig-param">image=None</em>, <em class="sig-param">integrator='trapezoidal'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#InterpolatedChromaticObject.drawImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.InterpolatedChromaticObject.drawImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw an image as seen through a particular bandpass using the stored interpolated
images at the specified wavelengths.</p>
<p>This integration will take place using interpolation between stored images that were
setup when the object was constructed.  (See interpolate() for more details.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – A Bandpass object representing the filter against which to
integrate.</p></li>
<li><p><strong>image</strong> – Optionally, the Image to draw onto.  (See GSObject.drawImage()
for details.)  [default: None]</p></li>
<li><p><strong>integrator</strong> – The integration algorithm to use, given as a string.  Either
‘midpoint’ or ‘trapezoidal’ is allowed. [default: ‘trapezoidal’]</p></li>
<li><p><strong>**kwargs</strong> – For all other kwarg options, see GSObject.drawImage()</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the drawn Image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.InterpolatedChromaticObject.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#InterpolatedChromaticObject.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.InterpolatedChromaticObject.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this ChromaticObject at a particular wavelength using interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength, as a GSObject.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.InterpolatedChromaticObject.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#InterpolatedChromaticObject.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.InterpolatedChromaticObject.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticSum">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticSum</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticSum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ChromaticObjects and/or GSObjects together.  If a GSObject is part of a sum, then its
SED is assumed to be flat with spectral density of 1 photon/s/cm**2/nm.</p>
<p>This is the type returned from <code class="docutils literal notranslate"><span class="pre">galsim.Add(objects)</span></code> if any of the objects are a
ChromaticObject.</p>
<p>Typically, you do not need to construct a ChromaticSum object explicitly.  Normally, you
would just use the + operator, which returns a ChromaticSum when used with chromatic objects:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bulge</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Sersic</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">half_light_radius</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span> <span class="o">*</span> <span class="n">bulge_sed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">disk</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Exponential</span><span class="p">(</span><span class="n">half_light_radius</span><span class="o">=</span><span class="mf">1.4</span><span class="p">)</span> <span class="o">*</span> <span class="n">disk_sed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gal</span> <span class="o">=</span> <span class="n">bulge</span> <span class="o">+</span> <span class="n">disk</span>
</pre></div>
</div>
<p>You can also use the Add() factory function, which returns a ChromaticSum object if any of
the individual objects are chromatic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gal</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Add</span><span class="p">([</span><span class="n">bulge</span><span class="p">,</span><span class="n">disk</span><span class="p">])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> – Unnamed args should be a list of objects to add.</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>propagate_gsparams</strong> – Whether to propagate gsparams to each of the components.  This
is normally a good idea, but there may be use cases where one
would not want to do this. [default: True]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticSum.drawImage">
<code class="sig-name descname">drawImage</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em>, <em class="sig-param">image=None</em>, <em class="sig-param">integrator='trapezoidal'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticSum.drawImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticSum.drawImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Slightly optimized draw method for ChromaticSum instances.</p>
<p>Draws each summand individually and add resulting images together.  This might waste time if
two or more summands are separable and have the same SED, and another summand with a
different SED is also added, in which case the summands should be added together first and
the resulting Sum object can then be chromaticized.  In general, however, drawing individual
sums independently can help with speed by identifying chromatic profiles that are separable
into spectral and spatial factors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – A Bandpass object representing the filter against which to
integrate.</p></li>
<li><p><strong>image</strong> – Optionally, the Image to draw onto.  (See GSObject.drawImage()
for details.)  [default: None]</p></li>
<li><p><strong>integrator</strong> – When doing the exact evaluation of the profile, this argument should
be one of the image integrators from galsim.integ, or a string
‘trapezoidal’ or ‘midpoint’, in which case the routine will use a
SampleIntegrator or ContinuousIntegrator depending on whether or not
the object has a <code class="docutils literal notranslate"><span class="pre">wave_list</span></code>.  [default: ‘trapezoidal’,
which will try to select an appropriate integrator using the
trapezoidal integration rule automatically.]</p></li>
<li><p><strong>**kwargs</strong> – For all other kwarg options, see GSObject.drawImage()</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the drawn Image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticSum.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticSum.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticSum.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this chromatic object at a particular wavelength <code class="docutils literal notranslate"><span class="pre">wave</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticSum.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticSum.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticSum.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticSum.withScaledFlux">
<code class="sig-name descname">withScaledFlux</code><span class="sig-paren">(</span><em class="sig-param">flux_ratio</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticSum.withScaledFlux"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticSum.withScaledFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply the flux of the object by <code class="docutils literal notranslate"><span class="pre">flux_ratio</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>flux_ratio</strong> – The factor by which to scale the flux.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the object with the new flux.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticConvolution">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticConvolution</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticConvolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticConvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolve ChromaticObjects and/or GSObjects together.  GSObjects are treated as having flat
spectra (in photons/sec/cm**2/nm).</p>
<p>This is the type returned from <code class="docutils literal notranslate"><span class="pre">galsim.Convolve(objects)</span></code> if any of the objects is a
ChromaticObject.</p>
<p>The normal way to use this class is to use the Convolve() factory function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gal</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Sersic</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">half_light_radius</span><span class="p">)</span> <span class="o">*</span> <span class="n">galsim</span><span class="o">.</span><span class="n">SED</span><span class="p">(</span><span class="n">sed_file</span><span class="p">,</span> <span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="s1">&#39;flambda&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ChromaticAtmosphere</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">final</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Convolve</span><span class="p">([</span><span class="n">gal</span><span class="p">,</span> <span class="n">psf</span><span class="p">])</span>
</pre></div>
</div>
<p>The objects to be convolved may be provided either as multiple unnamed arguments (e.g.
<code class="docutils literal notranslate"><span class="pre">Convolve(psf,</span> <span class="pre">gal,</span> <span class="pre">pix)</span></code>) or as a list (e.g. <code class="docutils literal notranslate"><span class="pre">Convolve([psf,</span> <span class="pre">gal,</span> <span class="pre">pix])</span></code>).  Any number of
objects may be provided using either syntax.  (Well, the list has to include at least 1 item.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> – Unnamed args should be a list of objects to convolve.</p></li>
<li><p><strong>real_space</strong> – Whether to use real space convolution.  [default: None, which means
to automatically decide this according to whether the objects have hard
edges.]</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>propagate_gsparams</strong> – Whether to propagate gsparams to each of the components.  This
is normally a good idea, but there may be use cases where one
would not want to do this. [default: True]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticConvolution.drawImage">
<code class="sig-name descname">drawImage</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em>, <em class="sig-param">image=None</em>, <em class="sig-param">integrator='trapezoidal'</em>, <em class="sig-param">iimult=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticConvolution.drawImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticConvolution.drawImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimized draw method for the ChromaticConvolution class.</p>
<p>Works by finding sums of profiles which include separable portions, which can then be
integrated before doing any convolutions, which are pushed to the end.</p>
<p>This method uses a cache to avoid recomputing ‘effective’ profiles, which are the
wavelength-integrated products of inseparable profiles, the spectral components of
separable profiles, and the bandpass.  Because the cache size is finite, users may find
that it is more efficient when drawing many images to group images using the same
SEDs, bandpasses, and inseparable profiles (generally PSFs) together in order to hit the
cache more often.  The default cache size is 10, but may be resized using the
<a class="reference internal" href="#galsim.ChromaticConvolution.resize_effective_prof_cache" title="galsim.ChromaticConvolution.resize_effective_prof_cache"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">ChromaticConvolution.resize_effective_prof_cache</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – A Bandpass object representing the filter against which to
integrate.</p></li>
<li><p><strong>image</strong> – Optionally, the Image to draw onto.  (See GSObject.drawImage()
for details.)  [default: None]</p></li>
<li><p><strong>integrator</strong> – When doing the exact evaluation of the profile, this argument should
be one of the image integrators from galsim.integ, or a string
‘trapezoidal’ or ‘midpoint’, in which case the routine will use a
SampleIntegrator or ContinuousIntegrator depending on whether or not
the object has a <code class="docutils literal notranslate"><span class="pre">wave_list</span></code>.  [default: ‘trapezoidal’,
which will try to select an appropriate integrator using the
trapezoidal integration rule automatically.]</p></li>
<li><p><strong>iimult</strong> – Oversample any intermediate InterpolatedImages created to hold
effective profiles by this amount. [default: None]</p></li>
<li><p><strong>**kwargs</strong> – For all other kwarg options, see GSObject.drawImage()</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the drawn Image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticConvolution.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticConvolution.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticConvolution.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this chromatic object at a particular wavelength <code class="docutils literal notranslate"><span class="pre">wave</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticConvolution.resize_effective_prof_cache">
<em class="property">static </em><code class="sig-name descname">resize_effective_prof_cache</code><span class="sig-paren">(</span><em class="sig-param">maxsize</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticConvolution.resize_effective_prof_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticConvolution.resize_effective_prof_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize the cache containing effective profiles, (i.e., wavelength-integrated products
of separable profile SEDs, inseparable profiles, and Bandpasses), which are used by
ChromaticConvolution.drawImage().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>maxsize</strong> – The new number of effective profiles to cache.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticConvolution.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticConvolution.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticConvolution.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticDeconvolution">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticDeconvolution</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">gsparams=None</em>, <em class="sig-param">propagate_gsparams=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticDeconvolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticDeconvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for deconvolving a ChromaticObject.</p>
<p>The ChromaticDeconvolution class represents a wavelength-dependent deconvolution kernel.</p>
<p>You may also specify a gsparams argument.  See the docstring for GSParams using
help(galsim.GSParams) for more information about this option.  Note: if <code class="docutils literal notranslate"><span class="pre">gsparams</span></code> is
unspecified (or None), then the ChromaticDeconvolution instance inherits the same GSParams as
the object being deconvolved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – The object to deconvolve.</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>propagate_gsparams</strong> – Whether to propagate gsparams to each of the components.  This
is normally a good idea, but there may be use cases where one
would not want to do this. [default: True]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticDeconvolution.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticDeconvolution.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticDeconvolution.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this chromatic object at a particular wavelength <code class="docutils literal notranslate"><span class="pre">wave</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticDeconvolution.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticDeconvolution.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticDeconvolution.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticAutoConvolution">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticAutoConvolution</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">real_space=None</em>, <em class="sig-param">gsparams=None</em>, <em class="sig-param">propagate_gsparams=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAutoConvolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAutoConvolution" title="Permalink to this definition">¶</a></dt>
<dd><p>A special class for convolving a ChromaticObject with itself.</p>
<p>It is equivalent in functionality to <code class="docutils literal notranslate"><span class="pre">galsim.Convolve([obj,obj])</span></code>, but takes advantage of
the fact that the two profiles are the same for some efficiency gains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – The object to be convolved with itself.</p></li>
<li><p><strong>real_space</strong> – Whether to use real space convolution.  [default: None, which means
to automatically decide this according to whether the objects have hard
edges.]</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>propagate_gsparams</strong> – Whether to propagate gsparams to each of the components.  This
is normally a good idea, but there may be use cases where one
would not want to do this. [default: True]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticAutoConvolution.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAutoConvolution.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAutoConvolution.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this chromatic object at a particular wavelength <code class="docutils literal notranslate"><span class="pre">wave</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticAutoConvolution.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAutoConvolution.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAutoConvolution.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticAutoCorrelation">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticAutoCorrelation</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">real_space=None</em>, <em class="sig-param">gsparams=None</em>, <em class="sig-param">propagate_gsparams=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAutoCorrelation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAutoCorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>A special class for correlating a ChromaticObject with itself.</p>
<p>It is equivalent in functionality to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">galsim</span><span class="o">.</span><span class="n">Convolve</span><span class="p">([</span><span class="n">obj</span><span class="p">,</span><span class="n">obj</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mf">180.</span><span class="o">*</span><span class="n">galsim</span><span class="o">.</span><span class="n">degrees</span><span class="p">)])</span>
</pre></div>
</div>
<p>but takes advantage of the fact that the two profiles are the same for some efficiency gains.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – The object to be convolved with itself.</p></li>
<li><p><strong>real_space</strong> – Whether to use real space convolution.  [default: None, which means
to automatically decide this according to whether the objects have hard
edges.]</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>propagate_gsparams</strong> – Whether to propagate gsparams to each of the components.  This
is normally a good idea, but there may be use cases where one
would not want to do this. [default: True]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticAutoCorrelation.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAutoCorrelation.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAutoCorrelation.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this chromatic object at a particular wavelength <code class="docutils literal notranslate"><span class="pre">wave</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticAutoCorrelation.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticAutoCorrelation.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticAutoCorrelation.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticTransformation">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticTransformation</code><span class="sig-paren">(</span><em class="sig-param">obj, jac=array([[1., 0.],        [0., 1.]]), offset=(0.0, 0.0), flux_ratio=1.0, gsparams=None, propagate_gsparams=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticTransformation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for modeling a wavelength-dependent affine transformation of a ChromaticObject
instance.</p>
<p>Typically, you do not need to construct a ChromaticTransformation object explicitly.
This is the type returned by the various transformation methods of ChromaticObject such as
shear(), rotate(), shift(), transform(), etc.  All the various transformations can be described
as a combination of transform() and shift(), which are described by (dudx,dudy,dvdx,dvdy) and
(dx,dy) respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – The object to be transformed.</p></li>
<li><p><strong>jac</strong> – A list or tuple ( dudx, dudy, dvdx, dvdy ), or a numpy.array object
[[dudx, dudy], [dvdx, dvdy]] describing the Jacobian to apply.  May
also be a function of wavelength returning a numpy array.
[default: (1,0,0,1)]</p></li>
<li><p><strong>offset</strong> – A galsim.PositionD or list or tuple or numpy array giving the offset by
which to shift the profile.  May also be a function of wavelength
returning a numpy array.  [default: (0,0)]</p></li>
<li><p><strong>flux_ratio</strong> – A factor by which to multiply the flux of the object. [default: 1]</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>propagate_gsparams</strong> – Whether to propagate gsparams to each of the components.  This
is normally a good idea, but there may be use cases where one
would not want to do this. [default: True]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticTransformation.drawImage">
<code class="sig-name descname">drawImage</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em>, <em class="sig-param">image=None</em>, <em class="sig-param">integrator='trapezoidal'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticTransformation.drawImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticTransformation.drawImage" title="Permalink to this definition">¶</a></dt>
<dd><p>See ChromaticObject.drawImage for a full description.</p>
<p>This version usually just calls that one, but if the transformed object (self.original) is
an InterpolatedChromaticObject, and the transformation is achromatic, then it will still be
able to use the interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – A Bandpass object representing the filter against which to
integrate.</p></li>
<li><p><strong>image</strong> – Optionally, the Image to draw onto.  (See GSObject.drawImage()
for details.)  [default: None]</p></li>
<li><p><strong>integrator</strong> – When doing the exact evaluation of the profile, this argument should
be one of the image integrators from galsim.integ, or a string
‘trapezoidal’ or ‘midpoint’, in which case the routine will use a
SampleIntegrator or ContinuousIntegrator depending on whether or not
the object has a <code class="docutils literal notranslate"><span class="pre">wave_list</span></code>.  [default: ‘trapezoidal’,
which will try to select an appropriate integrator using the
trapezoidal integration rule automatically.]
If the object being transformed is an InterpolatedChromaticObject,
then <code class="docutils literal notranslate"><span class="pre">integrator</span></code> can only be a string, either ‘midpoint’ or
‘trapezoidal’.</p></li>
<li><p><strong>**kwargs</strong> – For all other kwarg options, see GSObject.drawImage()</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the drawn Image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticTransformation.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticTransformation.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticTransformation.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this chromatic object at a particular wavelength.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticTransformation.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticTransformation.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticTransformation.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.ChromaticFourierSqrtProfile">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ChromaticFourierSqrtProfile</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">gsparams=None</em>, <em class="sig-param">propagate_gsparams=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticFourierSqrtProfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticFourierSqrtProfile" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for computing the Fourier-space square root of a ChromaticObject.</p>
<p>The ChromaticFourierSqrtProfile class represents a wavelength-dependent Fourier-space square
root of a profile.</p>
<p>You may also specify a gsparams argument.  See the docstring for GSParams using
help(galsim.GSParams) for more information about this option.  Note: if <code class="docutils literal notranslate"><span class="pre">gsparams</span></code> is
unspecified (or None), then the ChromaticFourierSqrtProfile instance inherits the same GSParams
as the object being operated on.</p>
<p>The normal way to use this class is to use the FourierSqrt() factory function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fourier_sqrt</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">FourierSqrt</span><span class="p">(</span><span class="n">chromatic_obj</span><span class="p">)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">chromatic_obj</span></code> is indeed a ChromaticObject, then that function will create a
ChromaticFourierSqrtProfile object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> – The object to compute the Fourier-space square root of.</p></li>
<li><p><strong>gsparams</strong> – An optional GSParams argument.  See the docstring for GSParams for
details. [default: None]</p></li>
<li><p><strong>propagate_gsparams</strong> – Whether to propagate gsparams to each of the components.  This
is normally a good idea, but there may be use cases where one
would not want to do this. [default: True]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.ChromaticFourierSqrtProfile.evaluateAtWavelength">
<code class="sig-name descname">evaluateAtWavelength</code><span class="sig-paren">(</span><em class="sig-param">wave</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticFourierSqrtProfile.evaluateAtWavelength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticFourierSqrtProfile.evaluateAtWavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate this chromatic object at a particular wavelength <code class="docutils literal notranslate"><span class="pre">wave</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wave</strong> – Wavelength in nanometers.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the monochromatic object at the given wavelength.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.ChromaticFourierSqrtProfile.withGSParams">
<code class="sig-name descname">withGSParams</code><span class="sig-paren">(</span><em class="sig-param">gsparams</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/chromatic.html#ChromaticFourierSqrtProfile.withGSParams"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ChromaticFourierSqrtProfile.withGSParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a version of the current object with the given gsparams</p>
<p>Note: if this object wraps other objects (e.g. Convolution, Sum, Transformation, etc.)
those component objects will also have their gsparams updated to the new value.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="spectral-correlated-noise">
<h2>Spectral Correlated Noise<a class="headerlink" href="#spectral-correlated-noise" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.CovarianceSpectrum">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">CovarianceSpectrum</code><span class="sig-paren">(</span><em class="sig-param">Sigma</em>, <em class="sig-param">SEDs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/correlatednoise.html#CovarianceSpectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CovarianceSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to hold a <a class="reference internal" href="#galsim.ChromaticSum" title="galsim.ChromaticSum"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticSum</span></code></a> noise covariance spectrum (which is a generalization of a
power spectrum or equivalently a correlation function).
Analogous to how a <a class="reference internal" href="noise.html#galsim.CorrelatedNoise" title="galsim.CorrelatedNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">galsim.CorrelatedNoise</span></code></a> object stores the variance and covariance of a
galsim.Image object, a <a class="reference internal" href="#galsim.CovarianceSpectrum" title="galsim.CovarianceSpectrum"><code class="xref any py py-class docutils literal notranslate"><span class="pre">galsim.CovarianceSpectrum</span></code></a> stores the variance and covariance of the
Fourier mode amplitudes in different components of a <a class="reference internal" href="#galsim.ChromaticSum" title="galsim.ChromaticSum"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticSum</span></code></a>.  Note that the covariance
in question exists between different SED-components of the <a class="reference internal" href="#galsim.ChromaticSum" title="galsim.ChromaticSum"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticSum</span></code></a>, and not between
different Fourier modes, which are assumed to be uncorrelated.  This structure arises naturally
for a <a class="reference internal" href="#galsim.ChromaticRealGalaxy" title="galsim.ChromaticRealGalaxy"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticRealGalaxy</span></code></a> (see devel/modules/CGNotes.pdf for more details).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Sigma</strong> – A dictionary whose keys are tuples numerically indicating a pair of <a class="reference internal" href="#galsim.ChromaticSum" title="galsim.ChromaticSum"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticSum</span></code></a>
components whose Fourier mode amplitude covariances are described by the
corresponding GSObject values.</p></li>
<li><p><strong>SEDs</strong> – SEDs of associated <a class="reference internal" href="#galsim.ChromaticSum" title="galsim.ChromaticSum"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticSum</span></code></a> components.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.CovarianceSpectrum.toNoise">
<code class="sig-name descname">toNoise</code><span class="sig-paren">(</span><em class="sig-param">bandpass</em>, <em class="sig-param">PSF</em>, <em class="sig-param">wcs</em>, <em class="sig-param">rng=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/correlatednoise.html#CovarianceSpectrum.toNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.CovarianceSpectrum.toNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Derive the galsim.CorrelatedNoise object for the associated <a class="reference internal" href="#galsim.ChromaticSum" title="galsim.ChromaticSum"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ChromaticSum</span></code></a> when convolved
with <code class="docutils literal notranslate"><span class="pre">PSF</span></code> and drawn through <code class="docutils literal notranslate"><span class="pre">bandpass</span></code> onto pixels with specified <code class="docutils literal notranslate"><span class="pre">wcs</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bandpass</strong> – galsim.Bandpass object representing filter image is drawn through.</p></li>
<li><p><strong>PSF</strong> – output chromatic PSF to convolve by.</p></li>
<li><p><strong>wcs</strong> – WCS of output pixel scale.</p></li>
<li><p><strong>rng</strong> – Random number generator to forward to resulting CorrelatedNoise object.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>CorrelatedNoise object.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="shear.html" class="btn btn-neutral float-right" title="Weak Lensing Shear" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="noise.html" class="btn btn-neutral float-left" title="Noise and Random Values" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, GalSim-developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>