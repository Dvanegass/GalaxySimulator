

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Weak Lensing Shear &mdash; GalSim 2.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Angles and Coordinates" href="coord.html" />
    <link rel="prev" title="Wavelength-dependent Profiles" href="chromatic.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="image.html">Images and Related Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Weak Lensing Shear</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-shear-class">The Shear class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#power-spectrum-shears">Power Spectrum Shears</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nfw-halo-shears">NFW Halo Shears</a></li>
<li class="toctree-l2"><a class="reference internal" href="#power-spectrum-estimation">Power Spectrum Estimation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="coord.html">Angles and Coordinates</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Weak Lensing Shear</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/shear.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="weak-lensing-shear">
<h1>Weak Lensing Shear<a class="headerlink" href="#weak-lensing-shear" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-shear-class">
<h2>The Shear class<a class="headerlink" href="#the-shear-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.Shear">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">Shear</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/shear.html#Shear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Shear" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to represent shears in a variety of ways.</p>
<p>The python Shear class (galsim.Shear) can be initialized in a variety of ways to represent shape
distortions.  A shear is an operation that transforms a circle into an ellipse with
minor-to-major axis ratio b/a, with position angle beta, while conserving the area (see
below for a discussion of the implications of this choice).  Given the multiple definitions of
ellipticity, we have multiple definitions of shear:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>reduced shear
    :math:`|g| = (a - b)/(a + b)`
distortion
    :math:`|e| = (a^2 - b^2)/(a^2 + b^2)`
conformal shear
    :math:`\eta = log(b/a)`
minor-to-major axis ratio
    :math:`q = b/a`
</pre></div>
</div>
<p>These can be thought of as a magnitude and a real-space position angle beta, or as two
components, e.g., g1 and g2, with:</p>
<div class="math notranslate nohighlight">
\[g1 = |g| cos(2*beta)
g2 = |g| sin(2*beta)\]</div>
<p>Note: beta is _not_ the phase of a complex valued shear.  Rather, the complex shear is
g1 + i g2 = g exp(2 i beta).  Likewise for eta or e.  The phase of the complex value is 2 beta.</p>
<p>The following are all examples of valid calls to initialize a Shear object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">()</span>                    <span class="c1"># empty constructor sets ellipticity/shear to zero</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">(</span><span class="n">g1</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">g2</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">(</span><span class="n">g1</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>             <span class="c1"># assumes g2=0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">(</span><span class="n">e1</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">e2</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">(</span><span class="n">e2</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>             <span class="c1"># assumes e1=0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">(</span><span class="n">eta1</span><span class="o">=</span><span class="mf">0.07</span><span class="p">,</span> <span class="n">eta2</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">(</span><span class="n">eta</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">45.0</span><span class="o">*</span><span class="n">galsim</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.25</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">galsim</span><span class="o">.</span><span class="n">radians</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">(</span><span class="n">e</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">30.0</span><span class="o">*</span><span class="n">galsim</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Shear</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.0</span><span class="o">*</span><span class="n">galsim</span><span class="o">.</span><span class="n">radians</span><span class="p">)</span>
</pre></div>
</div>
<p>There can be no mixing and matching, e.g., specifying <code class="docutils literal notranslate"><span class="pre">g1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code>.  It is permissible to
only specify one of two components, with the other assumed to be zero.  If a magnitude such as
<code class="docutils literal notranslate"><span class="pre">e</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">eta</span></code>, or <code class="docutils literal notranslate"><span class="pre">q</span></code> is specified, then <code class="docutils literal notranslate"><span class="pre">beta</span></code> is also required to be specified.
It is possible to initialize a Shear with zero reduced shear by specifying no args or kwargs,
i.e. <code class="docutils literal notranslate"><span class="pre">galsim.Shear()</span></code>.</p>
<p>In addition, for use cases where extreme efficiency is required, you can skip all the
normal sanity checks and branches in the regular Shear constructor by using a leading
underscore with the complex shear (g1 + 1j * g2):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">_Shear</span><span class="p">(</span><span class="mf">0.05</span> <span class="o">+</span> <span class="mf">0.03</span><span class="n">j</span><span class="p">)</span>  <span class="c1"># Equivalent to galsim.Shear(g1=0.05, g2=0.03)</span>
</pre></div>
</div>
<p>Since we have defined a Shear as a transformation that preserves area, this means that it is not
a precise description of what happens during the process of weak lensing.  The coordinate
transformation that occurs during the actual weak lensing process is such that if a galaxy is
sheared by some <code class="docutils literal notranslate"><span class="pre">(gamma_1,</span> <span class="pre">gamma_2)</span></code>, and then sheared by <code class="docutils literal notranslate"><span class="pre">(-gamma_1,</span> <span class="pre">-gamma_2)</span></code>, it will
in the end return to its original shape, but will have changed in area due to the magnification,
<code class="docutils literal notranslate"><span class="pre">mu</span> <span class="pre">=</span> <span class="pre">1/((1.-kappa)**2</span> <span class="pre">-</span> <span class="pre">(gamma_1**2</span> <span class="pre">+</span> <span class="pre">gamma_2**2))</span></code>, which is not equal to one for non-zero
shear even for convergence <code class="docutils literal notranslate"><span class="pre">kappa=0</span></code>.  Application of a Shear using the <a class="reference internal" href="gsobject.html#galsim.GSObject.shear" title="galsim.GSObject.shear"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.shear</span></code></a>
method does not include this area change.  To properly incorporate the effective change in
area due to shear, it is necessary to either (a) define the Shear object, use the
<a class="reference internal" href="gsobject.html#galsim.GSObject.shear" title="galsim.GSObject.shear"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.shear</span></code></a> method, and separately use the <a class="reference internal" href="gsobject.html#galsim.GSObject.magnify" title="galsim.GSObject.magnify"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.magnify</span></code></a> method, or (b) use the
<a class="reference internal" href="gsobject.html#galsim.GSObject.lens" title="galsim.GSObject.lens"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">GSObject.lens</span></code></a> method that simultaneously magnifies and shears.</p>
<dl class="method">
<dt id="galsim.Shear.getMatrix">
<code class="sig-name descname">getMatrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/shear.html#Shear.getMatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Shear.getMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the matrix that tells how this shear acts on a position vector:</p>
<p>If a field is sheared by some shear, s, then the position (x,y) -&gt; (x’,y’)
according to:</p>
<p>[ x’ ] = S [ x ]
[ y’ ]     [ y ]</p>
<p>where S = s.getMatrix().</p>
<dl class="simple">
<dt>Specifically, the matrix is S = (1-g^2)^(-1/2) [ 1+g1 ,  g2  ]</dt><dd><p>[  g2  , 1-g1 ]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Shear.rotationWith">
<code class="sig-name descname">rotationWith</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/shear.html#Shear.rotationWith"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Shear.rotationWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rotation angle associated with the addition of two shears.</p>
<p>The effect of two shears is not just a single net shear.  There is also a rotation
associated with it.  This is easiest to understand in terms of the matrix representations:</p>
<p>If s3 = s1 + s2, and the corresponding shear matrices are S1,S2,S3, then S3 R = S1 S2,
where R is a rotation matrix:</p>
<dl class="simple">
<dt>R = [ cos(theta) , -sin(theta) ]</dt><dd><p>[ sin(theta) ,  cos(theta) ]</p>
</dd>
</dl>
<p>and theta is the return value (as a galsim.Angle) from s1.rotationWith(s2).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="galsim._Shear">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">_Shear</code><span class="sig-paren">(</span><em class="sig-param">g</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/shear.html#_Shear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim._Shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to Shear(shear), but without the overhead of the normal sanity checks and other
options for how to specify the shear.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>g</strong> – The complex shear g1 + 1j * g2.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a galsim.Shear instance</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="power-spectrum-shears">
<h2>Power Spectrum Shears<a class="headerlink" href="#power-spectrum-shears" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.PowerSpectrum">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">PowerSpectrum</code><span class="sig-paren">(</span><em class="sig-param">e_power_function=None</em>, <em class="sig-param">b_power_function=None</em>, <em class="sig-param">delta2=False</em>, <em class="sig-param">units=coord.arcsec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/lensing_ps.html#PowerSpectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PowerSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to represent a lensing shear field according to some power spectrum P(k).</p>
<p>General considerations:</p>
<p>A PowerSpectrum represents some (flat-sky) shear power spectrum, either for gridded points or at
arbitary positions.  This class is originally initialized with a power spectrum from which we
would like to generate g1 and g2 (and, optionally, convergence kappa) values.  It generates
shears on a grid, and if necessary, when getShear() (or another <code class="docutils literal notranslate"><span class="pre">get</span></code> method) is called, it will
interpolate to the requested positions.  For detail on how these processes are carried out,
please see the document in the GalSim repository, <code class="docutils literal notranslate"><span class="pre">devel/modules/lensing_engine.pdf</span></code>.</p>
<p>This class generates the shears according to the input power spectrum using a DFT approach,
which means that we implicitly assume our discrete representation of P(k) on a grid is one
complete cell in an infinite periodic series.  We are making assumptions about what P(k) is
doing outside of our minimum and maximum k range, and those must be kept in mind when comparing
with theoretical expectations.  Specifically, since the power spectrum is realized on only a
finite grid it has been been effectively bandpass filtered between a minimum and maximum k value
in each of the k1, k2 directions.  See the <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> method for more information.</p>
<p>As a result, the shear generation currently does not include sample variance due to coverage of
a finite patch.  We explicitly enforce <code class="docutils literal notranslate"><span class="pre">P(k=0)=0</span></code>, which is true for the full sky in a
reasonable cosmological model, but it ignores the fact that our little patch of sky might
reasonably live in some special region with respect to shear correlations.  Our <code class="docutils literal notranslate"><span class="pre">P(k=0)=0</span></code> is
essentially setting the integrated power below our minimum k value to zero.  The implications of
the discrete representation, and the <code class="docutils literal notranslate"><span class="pre">P(k=0)=0</span></code> choice, are discussed in more detail in
<code class="docutils literal notranslate"><span class="pre">devel/modules/lensing_engine.pdf</span></code>.</p>
<p>The effective shear correlation function for the gridded points will be modified both because of
the DFT approach to representing shears according to a power spectrum, and because of the power
cutoff below and above the minimum k values.  The latter effect can be particularly important on
large scales, so the <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> method has some keywords that can be used to reduce the
impact of the minimum k set by the grid extent.  The calculateXi() method can be used to
calculate the expected shear correlation functions given the minimum and maximum k for some grid
(but ignoring the discrete vs. continuous Fourier transform effects), for comparison with some
ideal theoretical correlation function given an infinite k range.</p>
<p>When interpolating the shears to non-gridded points, the shear correlation function and power
spectrum are modified; see the getShear() and other <code class="docutils literal notranslate"><span class="pre">get</span></code> method docstrings for more details.</p>
<p>The power spectra to be used:</p>
<p>When creating a PowerSpectrum instance, you must specify at least one of the E or B mode power
spectra, which is normally given as a function P(k).  The typical thing is to just use a lambda
function in Python (i.e., a function that is not associated with a name); for example, to define
P(k)=k^2, one would use <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">k</span> <span class="pre">:</span> <span class="pre">k**2</span></code>.  But the power spectra can also be more complicated
user-defined functions that take a single argument <code class="docutils literal notranslate"><span class="pre">k</span></code> and return the power at that <code class="docutils literal notranslate"><span class="pre">k</span></code> value,
or they can be instances of the LookupTable class for power spectra that are known at
particular <code class="docutils literal notranslate"><span class="pre">k</span></code> values but for which there is not a simple analytic form.</p>
<p>Cosmologists often express the power spectra in terms of an expansion in spherical harmonics
(ell), i.e., the C_ell values.  In the flat-sky limit, we can replace ell with k and C_ell with
P(k).  Thus, k and P(k) have dimensions of inverse angle and angle^2, respectively.  It is quite
common for people to plot ell(ell+1)C_ell/2pi, a dimensionless quantity; the analogous flat-sky
quantity is Delta^2 = k^2 P(k)/2pi.  By default, the PowerSpectrum object assumes it is getting
P(k), but it is possible to instead give it Delta^2 by setting the optional keyword <code class="docutils literal notranslate"><span class="pre">delta2</span> <span class="pre">=</span>
<span class="pre">True</span></code> in the constructor.</p>
<p>The power functions must return a list/array that is the same size as what they are given, e.g.,
in the case of no power or constant power, a function that just returns a float would not be
permitted; it would have to return an array of floats all with the same value.</p>
<p>It is important to note that the power spectra used to initialize the PowerSpectrum object
should use the same units for k and P(k), i.e., if k is in inverse radians then P(k) should be
in radians^2 (as is natural for outputs from a cosmological shear power spectrum calculator).
However, when we actually draw images, there is a natural scale that defines the pitch of the
image, which is typically taken to be arcsec.  This definition of a specific length scale
means that by default we assume all quantities to the PowerSpectrum are in arcsec, and those are
the units used for internal calculations, but the <code class="docutils literal notranslate"><span class="pre">units</span></code> keyword can be used to specify
different input units for P(k) (again, within the constraint that k and P(k) must be
consistent).  If the <code class="docutils literal notranslate"><span class="pre">delta2</span></code> keyword is set to specify that the input is actually the
dimensionless power Delta^2, then the input <code class="docutils literal notranslate"><span class="pre">units</span></code> are taken to apply only to the k values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>e_power_function</strong> – A function or other callable that accepts a NumPy array of abs(k)
values, and returns the E-mode power spectrum P_E(abs(k)) in an array of
the same shape.  The function should return the power spectrum desired
in the E (gradient) mode of the image.
It may also be a string that can be converted to a function using
<code class="docutils literal notranslate"><span class="pre">eval('lambda</span> <span class="pre">k</span> <span class="pre">:</span> <span class="pre">'+e_power_function)</span></code>, a LookupTable, or <code class="docutils literal notranslate"><span class="pre">file_name</span></code>
from which to read in a LookupTable.  If a <code class="docutils literal notranslate"><span class="pre">file_name</span></code> is given, the
resulting LookupTable uses the defaults for the LookupTable class,
namely spline interpolation in P(k).  Users who wish to deviate from
those defaults (for example, to interpolate in log(P) and log(k), as
might be more natural for power-law functions) should instead read in
the file to create a LookupTable using the necessary non-default
settings. [default: None, which means no E-mode power.]</p></li>
<li><p><strong>b_power_function</strong> – A function or other callable that accepts a NumPy array of abs(k)
values, and returns the B-mode power spectrum P_B(abs(k)) in an array of
the same shape.  The function should return the power spectrum desired
in the B (curl) mode of the image.  See description of
<code class="docutils literal notranslate"><span class="pre">e_power_function</span></code> for input format options.
[default: None, which means no B-mode power.]</p></li>
<li><p><strong>delta2</strong> – Is the power actually given as dimensionless Delta^2, which requires us
to multiply by 2pi / k^2 to get the shear power P(k) in units of
angle^2?  [default: False]</p></li>
<li><p><strong>units</strong> – The angular units used for the power spectrum (i.e. the units of
k^-1 and sqrt(P)). This should be either an AngleUnit instance
(e.g. galsim.radians) or a string (e.g. ‘radians’). [default: arcsec]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.PowerSpectrum.buildGrid">
<code class="sig-name descname">buildGrid</code><span class="sig-paren">(</span><em class="sig-param">grid_spacing</em>, <em class="sig-param">ngrid</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">interpolant=None</em>, <em class="sig-param">center=galsim.PositionD(x=0.0</em>, <em class="sig-param">y=0.0)</em>, <em class="sig-param">units=coord.arcsec</em>, <em class="sig-param">get_convergence=False</em>, <em class="sig-param">kmax_factor=1</em>, <em class="sig-param">kmin_factor=1</em>, <em class="sig-param">bandlimit='hard'</em>, <em class="sig-param">variance=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/lensing_ps.html#PowerSpectrum.buildGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PowerSpectrum.buildGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a realization of the current power spectrum on the specified grid.</p>
<p>Basic functionality:</p>
<p>This function will generate a Gaussian random realization of the specified E and B mode
shear power spectra at a grid of positions, specified by the input parameters
<code class="docutils literal notranslate"><span class="pre">grid_spacing</span></code> (distance between grid points) and <code class="docutils literal notranslate"><span class="pre">ngrid</span></code> (number of grid points in
each direction.)  Units for <code class="docutils literal notranslate"><span class="pre">grid_spacing</span></code> and <code class="docutils literal notranslate"><span class="pre">center</span></code> can be specified using the
<code class="docutils literal notranslate"><span class="pre">units</span></code> keyword; the default is arcsec, which is how all values are stored internally.
It automatically computes and stores grids for the shears and convergence.  However, since
many users are primarily concerned with shape distortion due to shear, the default is to
return only the shear components; the <code class="docutils literal notranslate"><span class="pre">get_convergence</span></code> keyword can be used to also
return the convergence.</p>
<p>The quantities that are returned are the theoretical shears and convergences, usually
denoted gamma and kappa, respectively.  Users who wish to obtain the more
observationally-relevant reduced shear and magnification (that describe real lensing
distortions) can either use the getShear(), getMagnification(), or getLensing() methods
after <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a>, or can use the convenience function galsim.lensing_ps.theoryToObserved()
to convert from theoretical to observed quantities.</p>
<p>Effects of DFT approach, and keywords that can be used to ameliorate them:</p>
<p>Note that the shears generated using this method correspond to the PowerSpectrum multiplied
by a sharp bandpass filter, set by the dimensions of the grid.</p>
<p>The filter sets P(k) = 0 for:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">abs</span><span class="p">(</span><span class="n">k1</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">kmin</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>and:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">abs</span><span class="p">(</span><span class="n">k1</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">k2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">kmax</span> <span class="o">+</span> <span class="n">kmin</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kmin</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">ngrid</span> <span class="o">*</span> <span class="n">grid_spacing</span><span class="p">)</span>
<span class="n">kmax</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">grid_spacing</span>
</pre></div>
</div>
<p>and where we have adopted the convention that grid points at a given <code class="docutils literal notranslate"><span class="pre">k</span></code> represent the
interval between (k - dk/2) and (k + dk/2) (noting that the grid spacing dk in k space
is equivalent to <code class="docutils literal notranslate"><span class="pre">kmin</span></code>).</p>
<p>It is worth remembering that this bandpass filter will <em>not</em> look like a circular annulus
in 2D <code class="docutils literal notranslate"><span class="pre">k</span></code> space, but is rather more like a thick-sided picture frame, having a small
square central cutout of dimensions <code class="docutils literal notranslate"><span class="pre">kmin</span></code> by <code class="docutils literal notranslate"><span class="pre">kmin</span></code>.  These properties are visible in
the shears generated by this method.</p>
<p>If you care about these effects and want to ameliorate their effect, there are two
optional kwargs you can provide: <code class="docutils literal notranslate"><span class="pre">kmin_factor</span></code> and <code class="docutils literal notranslate"><span class="pre">kmax_factor</span></code>, both of which are 1
by default.  These should be integers &gt;= 1 that specify some factor smaller or larger
(for kmin and kmax respectively) you want the code to use for the underlying grid in
fourier space.  The final shear grid is returned using the specified <code class="docutils literal notranslate"><span class="pre">ngrid</span></code> and
<code class="docutils literal notranslate"><span class="pre">grid_spacing</span></code> parameters.  But the intermediate grid in Fourier space will be larger
by the specified factors.</p>
<p>Note: These are really just for convenience, since you could easily get the same effect
by providing different values of ngrid and grid_spacing and then take a subset of them.
The <code class="docutils literal notranslate"><span class="pre">kmin_factor</span></code> and <code class="docutils literal notranslate"><span class="pre">kmax_factor</span></code> just handle the scalings appropriately for you.</p>
<p>Use of <code class="docutils literal notranslate"><span class="pre">kmin_factor</span></code> and <code class="docutils literal notranslate"><span class="pre">kmax_factor</span></code> should depend on the desired application.  For
accurate representation of power spectra, one should not change these values from their
defaults of 1.  Changing them from one means the E- and B-mode power spectra that are input
will be valid for the larger intermediate grids that get generated in Fourier space, but not
necessarily for the smaller ones that get returned to the user.  However, for accurate
representation of cosmological shear correlation functions, use of <code class="docutils literal notranslate"><span class="pre">kmin_factor</span></code> larger
than one can be helpful in getting the shear correlations closer to the ideal theoretical
ones (see <code class="docutils literal notranslate"><span class="pre">devel/module/lensing_engine.pdf</span></code> for details).</p>
<p>Aliasing:</p>
<p>If the user provides a power spectrum that does not include a cutoff at kmax, then our
method of generating shears will result in aliasing that will show up in both E- and
B-modes.  Thus the <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> method accepts an optional keyword argument called
<code class="docutils literal notranslate"><span class="pre">bandlimit</span></code> that can tell the PowerSpectrum object to cut off power above kmax
automatically, where the relevant kmax is larger than the grid Nyquist frequency by a factor
of <code class="docutils literal notranslate"><span class="pre">kmax_factor</span></code>.  The allowed values for <code class="docutils literal notranslate"><span class="pre">bandlimit</span></code> are None (i.e., do nothing),
<code class="docutils literal notranslate"><span class="pre">hard</span></code> (set power to zero above the band limit), or <code class="docutils literal notranslate"><span class="pre">soft</span></code> (use an arctan-based
softening function to make the power go gradually to zero above the band limit).  By
default, <code class="docutils literal notranslate"><span class="pre">bandlimit=hard</span></code>.  Use of this keyword does nothing to the internal
representation of the power spectrum, so if the user calls the <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> method again,
they will need to set <code class="docutils literal notranslate"><span class="pre">bandlimit</span></code> again (and if their grid setup is different in a way
that changes <code class="docutils literal notranslate"><span class="pre">kmax</span></code>, then that’s fine).</p>
<p>Interpolation:</p>
<p>If the grid is being created for the purpose of later interpolating to random positions, the
following findings should be kept in mind: since the interpolant modifies the effective
shear correlation function on scales comparable to &lt;~3x the grid spacing, the grid spacing
should be chosen to be at least 3 times smaller than the minimum scales on which the user
wishes to reproduce the shear correlation function accurately.  Ideally, the grid should be
somewhat larger than the region in which shears at random points are needed, so that edge
effects in the interpolation will not be important.  For this purpose, there should be &gt;~5
grid points outside of the region in which interpolation will take place.  Ignoring this
edge effect and using the grid for interpolation out to its edges can suppress shear
correlations on all scales by an amount that depends on the grid size; for a 100x100 grid,
the suppression is ~2-3%.  Note that the above numbers came from tests that use a
cosmological shear power spectrum; precise figures for this suppression can also depend on
the shear correlation function itself.</p>
<p>Sign conventions and other info:</p>
<p>Note also that the convention for axis orientation differs from that for the GREAT10
challenge, so when using codes that deal with GREAT10 challenge outputs, the sign of our g2
shear component must be flipped.</p>
<p>For more information on the effects of finite grid representation of the power spectrum
see <code class="docutils literal notranslate"><span class="pre">devel/modules/lensing_engine.pdf</span></code>.</p>
<p>Some examples:</p>
<ol class="arabic">
<li><p>Get shears on a grid of points separated by 1 arcsec:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_ps</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PowerSpectrum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span> <span class="p">:</span> <span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">my_ps</span><span class="o">.</span><span class="n">buildGrid</span><span class="p">(</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">ngrid</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>The returned g1, g2 are 2-d NumPy arrays of values, corresponding to the values of
g1 and g2 at the locations of the grid points.</p>
<p>For a given value of <code class="docutils literal notranslate"><span class="pre">grid_spacing</span></code> and <code class="docutils literal notranslate"><span class="pre">ngrid</span></code>, we could get the x and y values on
the grid using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">ngrid</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">grid_spacing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span> <span class="o">=</span> <span class="p">(</span><span class="n">ngrid</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">grid_spacing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="nb">max</span><span class="o">+</span><span class="n">grid_spacing</span><span class="p">,</span><span class="n">grid_spacing</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="nb">max</span><span class="o">+</span><span class="n">grid_spacing</span><span class="p">,</span><span class="n">grid_spacing</span><span class="p">))</span>
</pre></div>
</div>
<p>where the center of the grid is taken to be (0,0).</p>
</li>
<li><p>Rebuild the grid using a particular rng and set the location of the center of the grid
to be something other than the default (0,0):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">my_ps</span><span class="o">.</span><span class="n">buildGrid</span><span class="p">(</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="mf">8.</span><span class="p">,</span> <span class="n">ngrid</span> <span class="o">=</span> <span class="mi">65</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">rng</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BaseDeviate</span><span class="p">(</span><span class="mi">1413231</span><span class="p">),</span>
<span class="gp">... </span>                         <span class="n">center</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="mf">256.5</span><span class="p">,</span> <span class="mf">256.5</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Make a PowerSpectrum from a tabulated P(k) that gets interpolated to find the power at
all necessary values of k, then generate shears and convergences on a grid, and convert
to reduced shear and magnification so they can be used to transform galaxy images.
E.g., assuming that k and P_k are NumPy arrays containing k and P(k):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tab_pk</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">LookupTable</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">P_k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_ps</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PowerSpectrum</span><span class="p">(</span><span class="n">tab_pk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">kappa</span> <span class="o">=</span> <span class="n">my_ps</span><span class="o">.</span><span class="n">buildGrid</span><span class="p">(</span><span class="n">grid_spacing</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">ngrid</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>                                <span class="n">get_convergence</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1_r</span><span class="p">,</span> <span class="n">g2_r</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">lensing_ps</span><span class="o">.</span><span class="n">theoryToObserved</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">kappa</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_spacing</strong> – Spacing for an evenly spaced grid of points, by default in arcsec
for consistency with the natural length scale of images created
using the drawImage() method.  Other units can be specified using
the <code class="docutils literal notranslate"><span class="pre">units</span></code> keyword.</p></li>
<li><p><strong>ngrid</strong> – Number of grid points in each dimension.  [Must be an integer]</p></li>
<li><p><strong>rng</strong> – A BaseDeviate object for drawing the random numbers. [default: None]</p></li>
<li><p><strong>interpolant</strong> – Interpolant that will be used for interpolating the gridded shears
by methods like getShear(), getConvergence(), etc. if they are
later called. [default: galsim.Lanczos(5)]</p></li>
<li><p><strong>center</strong> – If setting up a new grid, define what position you want to consider
the center of that grid.  Units must be consistent with those for
<code class="docutils literal notranslate"><span class="pre">grid_spacing</span></code>.  [default: galsim.PositionD(0,0)]</p></li>
<li><p><strong>units</strong> – The angular units used for the positions.  [default: arcsec]</p></li>
<li><p><strong>get_convergence</strong> – Return the convergence in addition to the shear?  Regardless of the
value of <code class="docutils literal notranslate"><span class="pre">get_convergence</span></code>, the convergence will still be computed
and stored for future use. [default: False]</p></li>
<li><p><strong>kmin_factor</strong> – <p>Factor by which the grid spacing in fourier space is smaller than
the default.  i.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kmin</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">ngrid</span> <span class="o">*</span> <span class="n">grid_spacing</span><span class="p">)</span> <span class="o">/</span> <span class="n">kmin_factor</span>
</pre></div>
</div>
<p>[default: 1; must be an integer]</p>
</p></li>
<li><p><strong>kmax_factor</strong> – <p>Factor by which the overall grid in fourier space is larger than
the default.  i.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kmax</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">grid_spacing</span> <span class="o">*</span> <span class="n">kmax_factor</span>
</pre></div>
</div>
<p>[default: 1; must be an integer]</p>
</p></li>
<li><p><strong>bandlimit</strong> – Keyword determining how to handle power P(k) above the limiting k
value, kmax.  The options None, ‘hard’, and ‘soft’ correspond to
doing nothing (i.e., allow P(&gt;kmax) to be aliased to lower k
values), cutting off all power above kmax, and applying a softening
filter to gradually cut off power above kmax.  Use of this keyword
does not modify the internally-stored power spectrum, just the
shears generated for this particular call to <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a>.
[default: “hard”]</p></li>
<li><p><strong>variance</strong> – Optionally renormalize the variance of the output shears to a
given value.  This is useful if you know the functional form of
the power spectrum you want, but not the normalization.  This lets
you set the normalization separately.  The resulting shears should
have var(g1) + var(g2) ~= variance.  If only e_power_function is
given, then this is also the variance of kappa.  Otherwise, the
variance of kappa may be smaller than the specified variance.
[default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the tuple (g1,g2[,kappa]), where each is a 2-d NumPy array and kappa is included
iff <code class="docutils literal notranslate"><span class="pre">get_convergence</span></code> is set to True.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.PowerSpectrum.calculateXi">
<code class="sig-name descname">calculateXi</code><span class="sig-paren">(</span><em class="sig-param">grid_spacing</em>, <em class="sig-param">ngrid</em>, <em class="sig-param">kmax_factor=1</em>, <em class="sig-param">kmin_factor=1</em>, <em class="sig-param">n_theta=100</em>, <em class="sig-param">units=coord.arcsec</em>, <em class="sig-param">bandlimit='hard'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/lensing_ps.html#PowerSpectrum.calculateXi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PowerSpectrum.calculateXi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate shear correlation functions for the current power spectrum on the specified
grid.</p>
<p>This function will calculate the theoretical shear correlation functions, <span class="math notranslate nohighlight">\(\xi_+\)</span>
and <span class="math notranslate nohighlight">\(\xi_-\)</span>, for this power spectrum and the grid configuration specified using
keyword arguments, taking into account the minimum and maximum k range implied by the grid
parameters, <code class="docutils literal notranslate"><span class="pre">kmin_factor</span></code> and <code class="docutils literal notranslate"><span class="pre">kmax_factor</span></code>.  Most theoretical correlation function
calculators assume an infinite k range, so this utility can be used to check how close the
chosen grid parameters (and the implied minimum and maximum k) come to the “ideal” result.
This is particularly useful on large scales, since in practice the finite grid extent
limits the minimum k value and therefore can suppress shear correlations on large scales.
Note that the actual shear correlation function in the generated shears will still differ
from the one calculated here due to differences between the discrete and continuous Fourier
transform.</p>
<p>The quantities that are returned are three NumPy arrays: separation theta (in the adopted
units), <span class="math notranslate nohighlight">\(\xi_+\)</span>, and <span class="math notranslate nohighlight">\(\xi_-\)</span>.  These are defined in terms of the E- and B-mode
shear power spectrum as in the document <code class="docutils literal notranslate"><span class="pre">devel/modules/lensing_engine.pdf</span></code>, equations 2
and 3.  The values that are returned are for a particular theta value, not an average over
a range of theta values in some bin of finite width.</p>
<p>This method has been tested with cosmological shear power spectra; users should check for
sanity of outputs if attempting to use power spectra that have very different scalings with
k.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid_spacing</strong> – Spacing for an evenly spaced grid of points, by default in arcsec
for consistency with the natural length scale of images created
using the drawImage() method.  Other units can be specified using
the <code class="docutils literal notranslate"><span class="pre">units</span></code> keyword.</p></li>
<li><p><strong>ngrid</strong> – Number of grid points in each dimension.  [Must be an integer]</p></li>
<li><p><strong>units</strong> – The angular units used for the positions.  [default = arcsec]</p></li>
<li><p><strong>kmin_factor</strong> – <p>(Optional) Factor by which the grid spacing in fourier space is
smaller than the default.  i.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kmin</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="n">ngrid</span> <span class="o">*</span> <span class="n">grid_spacing</span><span class="p">)</span> <span class="o">/</span> <span class="n">kmin_factor</span>
</pre></div>
</div>
<p>[default <code class="docutils literal notranslate"><span class="pre">kmin_factor</span> <span class="pre">=</span> <span class="pre">1</span></code>; must be an integer]</p>
</p></li>
<li><p><strong>kmax_factor</strong> – <p>(Optional) Factor by which the overall grid in fourier space is
larger than the default.  i.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kmax</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">grid_spacing</span> <span class="o">*</span> <span class="n">kmax_factor</span>
</pre></div>
</div>
<p>[default <code class="docutils literal notranslate"><span class="pre">kmax_factor</span> <span class="pre">=</span> <span class="pre">1</span></code>; must be an integer]</p>
</p></li>
<li><p><strong>n_theta</strong> – (Optional) Number of logarithmically spaced bins in angular
separation. [default <code class="docutils literal notranslate"><span class="pre">n_theta=100</span></code>]</p></li>
<li><p><strong>bandlimit</strong> – (Optional) Keyword determining how to handle power P(k) above the
limiting k value, kmax.  The options None, ‘hard’, and ‘soft’
correspond to doing nothing (i.e., allow P(&gt;kmax) to be aliased to
lower k values), cutting off all power above kmax, and applying a
softening filter to gradually cut off power above kmax.  Use of this
keyword does not modify the internally-stored power spectrum, just
the result generated by this particular call to <a class="reference internal" href="#galsim.PowerSpectrum.calculateXi" title="galsim.PowerSpectrum.calculateXi"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">calculateXi</span></code></a>.
[default <code class="docutils literal notranslate"><span class="pre">bandlimit=&quot;hard&quot;</span></code>]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the tuple (theta, xi_p, xi_m), 1-d NumPy arrays for the angular separation theta
and the two shear correlation functions.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.PowerSpectrum.getConvergence">
<code class="sig-name descname">getConvergence</code><span class="sig-paren">(</span><em class="sig-param">pos</em>, <em class="sig-param">units=coord.arcsec</em>, <em class="sig-param">periodic=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/lensing_ps.html#PowerSpectrum.getConvergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PowerSpectrum.getConvergence" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can interpolate between grid positions to find the convergence values for a
given list of input positions (or just a single position).  Before calling this function,
you must call <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> first to define the grid of convergences on which to interpolate.
The docstring for <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> provides some guidance on appropriate grid configurations to
use when building a grid that is to be later interpolated to random positions.</p>
<p>Note that the interpolation (specified when calling <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a>) modifies the effective
2-point functions of these quantities.  See docstring for getShear() docstring for caveats
about interpolation.  The user is advised to be very careful about deviating from the
default Lanczos-5 interpolant.</p>
<p>The usage of getConvergence() is the same as for getShear(), except that it returns only a
single quantity (convergence value or array of convergence values) rather than two
quantities.  See documentation for getShear() for some examples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> – <p>Position(s) of the source(s), assumed to be post-lensing!
Valid ways to input this:</p>
<ul>
<li><p>single PositionD (or PositionI) instance</p></li>
<li><p>tuple of floats: (x,y)</p></li>
<li><p>list or array of PositionD (or PositionI) instances</p></li>
<li><p>tuple of lists/arrays: ( xlist, ylist )</p></li>
</ul>
</p></li>
<li><p><strong>units</strong> – The angular units used for the positions.  [default: arcsec]</p></li>
<li><p><strong>periodic</strong> – Whether the interpolation should treat the positions as being defined
with respect to a periodic grid, which will wrap them around if they
are outside the bounds of the original grid on which shears and
convergences were defined.  If not, then convergences are set to zero
for positions outside the original grid.  [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the convergence, kappa (either a scalar or a numpy array)</p>
</dd>
</dl>
<p>If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a single position, kappa is the convergence value.
If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a list/array of positions, kappa is a NumPy array.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.PowerSpectrum.getLensing">
<code class="sig-name descname">getLensing</code><span class="sig-paren">(</span><em class="sig-param">pos</em>, <em class="sig-param">units=coord.arcsec</em>, <em class="sig-param">periodic=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/lensing_ps.html#PowerSpectrum.getLensing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PowerSpectrum.getLensing" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can interpolate between grid positions to find the lensing observable
quantities (reduced shears g1 and g2, and magnification mu) for a given list of input
positions (or just a single position).  Before calling this function, you must call
<a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> first to define the grid of shears and convergences on which to interpolate.
The docstring for <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> provides some guidance on appropriate grid configurations to
use when building a grid that is to be later interpolated to random positions.</p>
<p>Note that the interpolation (specified when calling <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a>) modifies the effective
2-point functions of these quantities.  See docstring for getShear() docstring for caveats
about interpolation.  The user is advised to be very careful about deviating from the
default Lanczos-5 interpolant.</p>
<p>The usage of getLensing() is the same as for getShear(), except that it returns three
quantities (two reduced shear components and magnification) rather than two.  See
documentation for getShear() for some examples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> – <p>Position(s) of the source(s), assumed to be post-lensing!
Valid ways to input this:</p>
<ul>
<li><p>single PositionD (or PositionI) instance</p></li>
<li><p>tuple of floats: (x,y)</p></li>
<li><p>list/array of PositionD (or PositionI) instances</p></li>
<li><p>tuple of lists/arrays: ( xlist, ylist )</p></li>
</ul>
</p></li>
<li><p><strong>units</strong> – The angular units used for the positions.  [default: arcsec]</p></li>
<li><p><strong>periodic</strong> – Whether the interpolation should treat the positions as being
defined with respect to a periodic grid, which will wrap them around
if they are outside the bounds of the original grid on which shears
and convergences were defined.  If not, then shear is set to zero
and magnification is set to 1 for positions outside the original
grid.  [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>shear and magnification as a tuple (g1,g2,mu).</p>
</dd>
</dl>
<p>If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a single position, the return values are the shear and
magnification values at that position.
If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a list/array of positions, they are NumPy arrays.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.PowerSpectrum.getMagnification">
<code class="sig-name descname">getMagnification</code><span class="sig-paren">(</span><em class="sig-param">pos</em>, <em class="sig-param">units=coord.arcsec</em>, <em class="sig-param">periodic=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/lensing_ps.html#PowerSpectrum.getMagnification"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PowerSpectrum.getMagnification" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can interpolate between grid positions to find the lensing magnification (mu)
values for a given list of input positions (or just a single position).  Before calling this
function, you must call <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> first to define the grid of shears and convergences on
which to interpolate.  The docstring for <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> provides some guidance on appropriate
grid configurations to use when building a grid that is to be later interpolated to random
positions.</p>
<p>Note that the interpolation (specified when calling <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a>) modifies the effective
2-point functions of these quantities.  See docstring for getShear() docstring for caveats
about interpolation.  The user is advised to be very careful about deviating from the
default Lanczos-5 interpolant.</p>
<p>The usage of getMagnification() is the same as for getShear(), except that it returns only a
single quantity (a magnification value or array of magnification values) rather than a pair
of quantities.  See documentation for getShear() for some examples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> – <p>Position(s) of the source(s), assumed to be post-lensing!
Valid ways to input this:</p>
<ul>
<li><p>single PositionD (or PositionI) instance</p></li>
<li><p>tuple of floats: (x,y)</p></li>
<li><p>list/array of PositionD (or PositionI) instances</p></li>
<li><p>tuple of lists/arrays: ( xlist, ylist )</p></li>
</ul>
</p></li>
<li><p><strong>units</strong> – The angular units used for the positions.  [default: arcsec]</p></li>
<li><p><strong>periodic</strong> – Whether the interpolation should treat the positions as being
defined with respect to a periodic grid, which will wrap them around
if they are outside the bounds of the original grid on which shears
and convergences were defined.  If not, then magnification is set to
1 for positions outside the original grid.  [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the magnification, mu (either a scalar or a numpy array)</p>
</dd>
</dl>
<p>If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a single position, mu is the magnification value.
If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a list/array of positions, mu is a NumPy array.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.PowerSpectrum.getShear">
<code class="sig-name descname">getShear</code><span class="sig-paren">(</span><em class="sig-param">pos</em>, <em class="sig-param">units=coord.arcsec</em>, <em class="sig-param">reduced=True</em>, <em class="sig-param">periodic=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/lensing_ps.html#PowerSpectrum.getShear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PowerSpectrum.getShear" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can interpolate between grid positions to find the shear values for a given
list of input positions (or just a single position).  Before calling this function, you must
call <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> first to define the grid of shears and convergences on which to
interpolate.  The docstring for <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> provides some guidance on appropriate grid
configurations to use when building a grid that is to be later interpolated to random
positions.</p>
<p>By default, this method returns the reduced shear, which is defined in terms of shear and
convergence as reduced shear <code class="docutils literal notranslate"><span class="pre">g=gamma/(1-kappa)</span></code>; the <code class="docutils literal notranslate"><span class="pre">reduced</span></code> keyword can be set to
False in order to return the non-reduced shear.</p>
<p>Note that the interpolation (specified when calling <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a>) modifies the effective
shear power spectrum and correlation function somewhat, though the effects can be limited
by careful choice of grid parameters (see buildGrid() docstring for details).  Assuming
those guidelines are followed, then the shear correlation function modifications due to use
of the quintic, Lanczos-3, and Lanczos-5 interpolants are below 5% on all scales from the
grid spacing to the total grid extent, typically below 2%.  The linear, cubic, and nearest
interpolants perform significantly more poorly, with modifications of the correlation
functions that can reach tens of percent on the scales where the recommended interpolants
perform well.  Thus, the default interpolant is Lanczos-5, and users should think carefully
about the acceptability of significant modification of the shear correlation function before
changing to use linear, cubic, or nearest.</p>
<p>Users who wish to ensure that the shear power spectrum is preserved post-interpolation
should consider using the <code class="docutils literal notranslate"><span class="pre">periodic</span></code> interpolation option, which assumes the shear field
is periodic (i.e., the sky is tiled with many copies of the given shear field).  Those who
care about the correlation function should not use this option, and for this reason it’s
not the default.</p>
<p>Some examples of how to use getShear():</p>
<ol class="arabic">
<li><p>Get the shear for a particular point:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">my_ps</span><span class="o">.</span><span class="n">getShear</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">412</span><span class="p">))</span>
</pre></div>
</div>
<p>This time the returned values are just floats and correspond to the shear for the
provided position.</p>
</li>
<li><p>You can also provide a position as a tuple to save the explicit PositionD construction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">my_ps</span><span class="o">.</span><span class="n">getShear</span><span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">412</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p>Get the shears for a bunch of points at once:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xlist</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">141</span><span class="p">,</span> <span class="mi">313</span><span class="p">,</span>  <span class="mi">12</span><span class="p">,</span> <span class="mi">241</span><span class="p">,</span> <span class="mi">342</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ylist</span> <span class="o">=</span> <span class="p">[</span>  <span class="mi">75</span><span class="p">,</span> <span class="mi">199</span><span class="p">,</span> <span class="mi">306</span><span class="p">,</span> <span class="mi">225</span><span class="p">,</span> <span class="mi">489</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">poslist</span> <span class="o">=</span> <span class="p">[</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="n">xlist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">ylist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xlist</span><span class="p">))</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">my_ps</span><span class="o">.</span><span class="n">getShear</span><span class="p">(</span> <span class="n">poslist</span> <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">my_ps</span><span class="o">.</span><span class="n">getShear</span><span class="p">(</span> <span class="p">(</span><span class="n">xlist</span><span class="p">,</span> <span class="n">ylist</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Both calls do the same thing.  The returned g1, g2 this time are numpy arrays of g1, g2
values.  The arrays are the same length as the number of input positions.</p>
</li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> – <p>Position(s) of the source(s), assumed to be post-lensing!
Valid ways to input this:</p>
<ul>
<li><p>single PositionD (or PositionI) instance</p></li>
<li><p>tuple of floats: (x,y)</p></li>
<li><p>list/array of PositionD (or PositionI) instances</p></li>
<li><p>tuple of lists/arrays: ( xlist, ylist )</p></li>
</ul>
</p></li>
<li><p><strong>units</strong> – The angular units used for the positions.  [default: arcsec]</p></li>
<li><p><strong>reduced</strong> – Whether returned shear(s) should be reduced shears. [default: True]</p></li>
<li><p><strong>periodi</strong> – Whether the interpolation should treat the positions as being defined
with respect to a periodic grid, which will wrap them around if they
are outside the bounds of the original grid on which shears were
defined.  If not, then shears are set to zero for positions outside the
original grid. [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the shear as a tuple, (g1,g2)</p>
</dd>
</dl>
<p>If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a single position, (g1,g2) are the two shear components.
If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a list/array of positions, they are NumPy arrays.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.PowerSpectrum.nRandCallsForBuildGrid">
<code class="sig-name descname">nRandCallsForBuildGrid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/lensing_ps.html#PowerSpectrum.nRandCallsForBuildGrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PowerSpectrum.nRandCallsForBuildGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times the rng() was called the last time <a class="reference internal" href="#galsim.PowerSpectrum.buildGrid" title="galsim.PowerSpectrum.buildGrid"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">buildGrid</span></code></a> was called.</p>
<p>This can be useful for keeping rngs in sync if the connection between them is broken
(e.g. when calling the function through a Proxy object).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="nfw-halo-shears">
<h2>NFW Halo Shears<a class="headerlink" href="#nfw-halo-shears" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.NFWHalo">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">NFWHalo</code><span class="sig-paren">(</span><em class="sig-param">mass</em>, <em class="sig-param">conc</em>, <em class="sig-param">redshift</em>, <em class="sig-param">halo_pos=galsim.PositionD(x=0.0</em>, <em class="sig-param">y=0.0)</em>, <em class="sig-param">omega_m=None</em>, <em class="sig-param">omega_lam=None</em>, <em class="sig-param">cosmo=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/nfw_halo.html#NFWHalo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.NFWHalo" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for NFW halos.</p>
<p>Compute the lensing fields shear and convergence of a spherically symmetric NFW halo of given
mass, concentration, redshift, assuming Cosmology. No mass-concentration relation is employed.</p>
<p>Based on Matthias Bartelmann’s libastro.</p>
<p>The cosmology to use can be set either by providing a Cosmology instance as cosmo,
or by providing omega_m and/or omega_lam.
If only one of the latter is provided, the other is taken to be one minus that.
If no cosmology parameters are set, a default Cosmology is constructed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mass</strong> – Mass defined using a spherical overdensity of 200 times the critical density
of the universe, in units of M_solar/h.</p></li>
<li><p><strong>conc</strong> – Concentration parameter, i.e., ratio of virial radius to NFW scale radius.</p></li>
<li><p><strong>redshift</strong> – Redshift of the halo.</p></li>
<li><p><strong>halo_pos</strong> – Position of halo center (in arcsec). [default: PositionD(0,0)]</p></li>
<li><p><strong>omega_m</strong> – Omega_matter to pass to Cosmology constructor. [default: None]</p></li>
<li><p><strong>omega_lam</strong> – Omega_lambda to pass to Cosmology constructor. [default: None]</p></li>
<li><p><strong>cosmo</strong> – A Cosmology instance. [default: None]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.NFWHalo.getConvergence">
<code class="sig-name descname">getConvergence</code><span class="sig-paren">(</span><em class="sig-param">pos</em>, <em class="sig-param">z_s</em>, <em class="sig-param">units=coord.arcsec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/nfw_halo.html#NFWHalo.getConvergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.NFWHalo.getConvergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate convergence of halo at specified positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> – <p>Position(s) of the source(s), assumed to be post-lensing!
Valid ways to input this:</p>
<ul>
<li><p>single PositionD (or PositionI) instance</p></li>
<li><p>tuple of floats: (x,y)</p></li>
<li><p>list/array of PositionD (or PositionI) instances</p></li>
<li><p>tuple of lists/arrays: ( xlist, ylist )</p></li>
</ul>
</p></li>
<li><p><strong>z_s</strong> – Source redshift(s).</p></li>
<li><p><strong>unit</strong> – Angular units of coordinates (only arcsec implemented so far).
[default: galsim.arcsec]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the convergence, kappa</p>
</dd>
</dl>
<p>If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a single position, kappa is the convergence value.
If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a list/array of positions, kappa is a NumPy array.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.NFWHalo.getLensing">
<code class="sig-name descname">getLensing</code><span class="sig-paren">(</span><em class="sig-param">pos</em>, <em class="sig-param">z_s</em>, <em class="sig-param">units=coord.arcsec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/nfw_halo.html#NFWHalo.getLensing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.NFWHalo.getLensing" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate lensing shear and magnification of halo at specified positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> – <p>Position(s) of the source(s), assumed to be post-lensing!
Valid ways to input this:</p>
<ul>
<li><p>single PositionD (or PositionI) instance</p></li>
<li><p>tuple of floats: (x,y)</p></li>
<li><p>list/array of PositionD (or PositionI) instances</p></li>
<li><p>tuple of lists/arrays: ( xlist, ylist )</p></li>
</ul>
</p></li>
<li><p><strong>z_s</strong> – Source redshift(s).</p></li>
<li><p><strong>units</strong> – Angular units of coordinates (only arcsec implemented so far).
[default: galsim.arcsec]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the reduced shears and magnifications as a tuple (g1,g2,mu)</p>
</dd>
</dl>
<p>If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a single position, the return values are the shear and
magnification values at that position.
If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a list/array of positions, they are NumPy arrays.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.NFWHalo.getMagnification">
<code class="sig-name descname">getMagnification</code><span class="sig-paren">(</span><em class="sig-param">pos</em>, <em class="sig-param">z_s</em>, <em class="sig-param">units=coord.arcsec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/nfw_halo.html#NFWHalo.getMagnification"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.NFWHalo.getMagnification" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate magnification of halo at specified positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> – <p>Position(s) of the source(s), assumed to be post-lensing!
Valid ways to input this:</p>
<ul>
<li><p>single PositionD (or PositionI) instance</p></li>
<li><p>tuple of floats: (x,y)</p></li>
<li><p>list/array of PositionD (or PositionI) instances</p></li>
<li><p>tuple of lists/arrays: ( xlist, ylist )</p></li>
</ul>
</p></li>
<li><p><strong>z_s</strong> – Source redshift(s).</p></li>
<li><p><strong>units</strong> – Angular units of coordinates (only arcsec implemented so far).
[default: galsim.arcsec]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the magnification mu</p>
</dd>
</dl>
<p>If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a single position, mu is the magnification value.
If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a list/array of positions, mu is a NumPy array.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.NFWHalo.getShear">
<code class="sig-name descname">getShear</code><span class="sig-paren">(</span><em class="sig-param">pos</em>, <em class="sig-param">z_s</em>, <em class="sig-param">units=coord.arcsec</em>, <em class="sig-param">reduced=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/nfw_halo.html#NFWHalo.getShear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.NFWHalo.getShear" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate (reduced) shear of halo at specified positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>po</strong> – <p>Position(s) of the source(s), assumed to be post-lensing!
Valid ways to input this:</p>
<ul>
<li><p>single PositionD (or PositionI) instance</p></li>
<li><p>tuple of floats: (x,y)</p></li>
<li><p>list/array of PositionD (or PositionI) instances</p></li>
<li><p>tuple of lists/arrays: ( xlist, ylist )</p></li>
</ul>
</p></li>
<li><p><strong>z_s</strong> – Source redshift(s).</p></li>
<li><p><strong>units</strong> – Angular units of coordinates (only arcsec implemented so far).
[default: galsim.arcsec]</p></li>
<li><p><strong>reduced</strong> – Whether returned shear(s) should be reduced shears. [default: True]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the (possibly reduced) shears as a tuple (g1,g2)</p>
</dd>
</dl>
<p>If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a single position, (g1,g2) are the two shear components.
If the input <code class="docutils literal notranslate"><span class="pre">pos</span></code> is given a list/array of positions, they are NumPy arrays.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.Cosmology">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">Cosmology</code><span class="sig-paren">(</span><em class="sig-param">omega_m=0.3</em>, <em class="sig-param">omega_lam=0.7</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/nfw_halo.html#Cosmology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Cosmology" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic cosmology calculations.</p>
<p>Cosmology calculates expansion function E(a) and angular diameter distances Da(z) for a
LambdaCDM universe.  Radiation is assumed to be zero and Dark Energy constant with w = -1 (no
quintessence), but curvature is arbitrary.</p>
<p>Based on Matthias Bartelmann’s libastro.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>omega_m</strong> – Present day energy density of matter relative to critical density.
[default: 0.3]</p></li>
<li><p><strong>omega_lam</strong> – Present day density of Dark Energy relative to critical density.
[default: 0.7]</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="galsim.Cosmology.Da">
<code class="sig-name descname">Da</code><span class="sig-paren">(</span><em class="sig-param">z</em>, <em class="sig-param">z_ref=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/nfw_halo.html#Cosmology.Da"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Cosmology.Da" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute angular diameter distance between two redshifts in units of c/H0.</p>
<p>In order to get the distance in Mpc/h, multiply by c/H0~3000.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>z</strong> – Redshift.</p></li>
<li><p><strong>z_ref</strong> – Reference redshift, with z_ref &lt;= z. [default: 0]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Cosmology.E">
<code class="sig-name descname">E</code><span class="sig-paren">(</span><em class="sig-param">a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/nfw_halo.html#Cosmology.E"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Cosmology.E" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates expansion function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> – Scale factor.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Cosmology.a">
<code class="sig-name descname">a</code><span class="sig-paren">(</span><em class="sig-param">z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/nfw_halo.html#Cosmology.a"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Cosmology.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute scale factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>z</strong> – Redshift</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="power-spectrum-estimation">
<h2>Power Spectrum Estimation<a class="headerlink" href="#power-spectrum-estimation" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.pse.PowerSpectrumEstimator">
<em class="property">class </em><code class="sig-prename descclassname">galsim.pse.</code><code class="sig-name descname">PowerSpectrumEstimator</code><span class="sig-paren">(</span><em class="sig-param">N=100</em>, <em class="sig-param">sky_size_deg=10.0</em>, <em class="sig-param">nbin=15</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/pse.html#PowerSpectrumEstimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.pse.PowerSpectrumEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for estimating the shear power spectrum from gridded shears.</p>
<p>The PowerSpectrumEstimator class can be used even on systems where GalSim is not installed.
It just requires NumPy.</p>
<p>This class stores all the data used in power spectrum estimation that is fixed with the geometry
of the problem - the binning and spin weighting factors.</p>
<p>The only public method is estimate(), which is called with 2D <code class="docutils literal notranslate"><span class="pre">g1</span></code> and <code class="docutils literal notranslate"><span class="pre">g2</span></code> arrays on a
square grid.  It assumes the flat sky approximation (where <code class="docutils literal notranslate"><span class="pre">ell</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code> are
interchangeable), and rebins the observed ell modes into a user-defined number of logarithimic
bins in ell.  Given that the grid parameters are precomputed and stored when the
<a class="reference internal" href="#galsim.pse.PowerSpectrumEstimator" title="galsim.pse.PowerSpectrumEstimator"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PowerSpectrumEstimator</span></code></a> is initialized, computation of the PS for multiple sets of shears
corresponding to the same grid setup can proceed more rapidly than if everything had to be
recomputed each time.</p>
<p>Below is an example of how to use this code (relying on GalSim to provide the arrays of g1 and
g2, though that is by no means required, and assuming that the user is sitting in the examples/
directory):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">grid_size</span> <span class="o">=</span> <span class="mf">10.</span>  <span class="c1"># Define the total grid extent, in degrees</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ngrid</span> <span class="o">=</span> <span class="mi">100</span>      <span class="c1"># Define the number of grid points in each dimension: (ngrid x ngrid)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_ell</span> <span class="o">=</span> <span class="mi">15</span>       <span class="c1"># Choose the number of logarithmic bins in ell or k for outputs</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define a lookup-table for the power spectrum as a function of k based on the outputs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># of iCosmo (see demo11.py for more description of how this was generated).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_tab</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">LookupTable</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s1">&#39;data/cosmo-fid.zmed1.00.out&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate a galsim.PowerSpectrum with this P(k), noting the units.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_ps</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PowerSpectrum</span><span class="p">(</span><span class="n">my_tab</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">galsim</span><span class="o">.</span><span class="n">radians</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Build a grid of shear values with the desired parameters.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">my_ps</span><span class="o">.</span><span class="n">buildGrid</span><span class="p">(</span><span class="n">grid_spacing</span><span class="o">=</span><span class="n">grid_size</span><span class="o">/</span><span class="n">ngrid</span><span class="p">,</span> <span class="n">ngrid</span><span class="o">=</span><span class="n">ngrid</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">units</span><span class="o">=</span><span class="n">galsim</span><span class="o">.</span><span class="n">degrees</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initialize a PowerSpectrumEstimator with the chosen grid geometry and number of ell</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># bins. Note that these values are actually the default, so we didn&#39;t technically have</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># to specifythem.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_pse</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">pse</span><span class="o">.</span><span class="n">PowerSpectrumEstimator</span><span class="p">(</span><span class="n">ngrid</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">n_ell</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Estimate the power based on this set of g1, g2.  If we get another set of shears for</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the same grid geometry, we can reuse the same PowerSpectrumEstimator object.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ell</span><span class="p">,</span> <span class="n">P_e</span><span class="p">,</span> <span class="n">P_b</span><span class="p">,</span> <span class="n">P_eb</span> <span class="o">=</span> <span class="n">my_pse</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span>
</pre></div>
</div>
<p>The output NumPy arrays <code class="docutils literal notranslate"><span class="pre">ell</span></code>, <code class="docutils literal notranslate"><span class="pre">P_e</span></code>, <code class="docutils literal notranslate"><span class="pre">P_b</span></code>, and <code class="docutils literal notranslate"><span class="pre">P_eb</span></code> contain the effective ell
value, the E-mode auto-power spectrum, the B-mode auto-power spectrum, and the EB cross-power
spectrum.  The units are inverse radians for ell, and radians^2 for the output power spectra.</p>
<p>Some important notes:</p>
<p>1) Power spectrum estimation requires a weight function which decides how the averaging is done
across ell within each bin.  By default that weighting is flat in ell using an analytic
calculation of the area in ell space, but this is easy to change with the <code class="docutils literal notranslate"><span class="pre">_bin_power</span></code>
function.  (Note this area averaged bin weighting is only approximate for the higher frequency
bins in which the lower <code class="docutils literal notranslate"><span class="pre">ell</span></code> edge is greater than <code class="docutils literal notranslate"><span class="pre">pi</span> <span class="pre">*</span> <span class="pre">ngrid</span> <span class="pre">/</span> <span class="pre">grid_size</span></code>, due to the
annular <code class="docutils literal notranslate"><span class="pre">ell</span></code> region being cut off by the square grid edges beyond this value.)  A keyword
allows for weighting by the power itself, but use of this functionality requires the GalSim
software package.</p>
<p>2) This is the power spectrum of the gridded <em>data</em>, not the underlying field - we do not
account for the effects of the finite grid (basically, ignoring all the reasons why power
spectrum estimation is hard - see devel/modules/lensing_engine.pdf in the GalSim repository).
Users must account for the contribution of noise in <code class="docutils literal notranslate"><span class="pre">g1</span></code>, <code class="docutils literal notranslate"><span class="pre">g2</span></code> and any masking.</p>
<ol class="arabic simple" start="3">
<li><p>The binning is currently fixed as uniform in log(ell).</p></li>
</ol>
<p>4) The code for this class uses the notation of the GREAT10 handbook (Kitching et al. 2011,
<a class="reference external" href="http://dx.doi.org/10.1214/11-AOAS484">http://dx.doi.org/10.1214/11-AOAS484</a>), equations 17-21.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="coord.html" class="btn btn-neutral float-right" title="Angles and Coordinates" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="chromatic.html" class="btn btn-neutral float-left" title="Wavelength-dependent Profiles" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, GalSim-developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>