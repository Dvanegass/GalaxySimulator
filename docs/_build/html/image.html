

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Images and Related Concepts &mdash; GalSim 2.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Surface Brightness Profiles" href="sb.html" />
    <link rel="prev" title="Installation Instructions" href="install.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> GalSim
          

          
          </a>

          
            
            
              <div class="version">
                2.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation Instructions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Images and Related Concepts</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-image-class">The Image class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bounding-boxes">Bounding boxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#positions">Positions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="sb.html">Surface Brightness Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="wcs.html">World Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Noise and Random Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="chromatic.html">Wavelength-dependent Profiles</a></li>
<li class="toctree-l1"><a class="reference internal" href="shear.html">Weak Lensing Shear</a></li>
<li class="toctree-l1"><a class="reference internal" href="coord.html">Angles and Coordinates</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Helper Functions and Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="config.html">The Config Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="hsm.html">The HSM Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="des.html">The DES Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="wfirst.html">The WFIRST Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">Revision History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">GalSim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Images and Related Concepts</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/image.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="images-and-related-concepts">
<h1>Images and Related Concepts<a class="headerlink" href="#images-and-related-concepts" title="Permalink to this headline">¶</a></h1>
<p>The main purpose of GalSim is normally to create images that simulate real astronomical
observations.  As such, the <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class is the most common class in GalSim that you will
likely be working with.</p>
<div class="section" id="the-image-class">
<h2>The Image class<a class="headerlink" href="#the-image-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.Image">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">Image</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for storing image data along with the pixel scale or WCS information</p>
<p>The Image class encapsulates all the relevant information about an image including a NumPy array
for the pixel values, a bounding box, and some kind of WCS that converts between pixel
coordinates and world coordinates.  The NumPy array may be constructed by the Image class
itself, or an existing array can be provided by the user.</p>
<p>This class creates shallow copies unless a deep copy is explicitly requested using the <a class="reference internal" href="#galsim.Image.copy" title="galsim.Image.copy"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">copy</span></code></a>
method.  The main reason for this is that it allows users to work directly with and modify
subimages of larger images (for example, to successively draw many galaxies into one large
image).  For other implications of this convention, see the description of initialization
instructions below.</p>
<p>In most applications with images, we will use (x,y) to refer to the coordinates.  We adopt
the same meaning for these coordinates as most astronomy applications do: ds9, SAOImage,
SExtractor, etc. all treat x as the column number and y as the row number.  However, this
is different from the default convention used by numpy.  In numpy, the access is by
[row_num,col_num], which means this is really [y,x] in terms of the normal x,y values.
Users are typically insulated from this concern by the Image API, but if you access the
numpy array directly via the <code class="docutils literal notranslate"><span class="pre">array</span></code> attribute, you will need to be careful about this
difference.</p>
<p>There are 6 data types that the Image can use for the data values.  These are <code class="docutils literal notranslate"><span class="pre">numpy.uint16</span></code>,
<code class="docutils literal notranslate"><span class="pre">numpy.uint32</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.int16</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.int32</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.float32</span></code>, and <code class="docutils literal notranslate"><span class="pre">numpy.float64</span></code>.
If you are constructing a new Image from scratch, the default is <code class="docutils literal notranslate"><span class="pre">numpy.float32</span></code>, but you
can specify one of the other data types.</p>
<p>There are several ways to construct an Image:
(Optional arguments are shown with their default values after the = sign.)</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">Image(ncol,</span> <span class="pre">nrow,</span> <span class="pre">dtype=numpy.float32,</span> <span class="pre">init_value=0,</span> <span class="pre">xmin=1,</span> <span class="pre">ymin=1,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>This constructs a new image, allocating memory for the pixel values according to
the number of columns and rows.  You can specify the data type as <code class="docutils literal notranslate"><span class="pre">dtype</span></code> if you
want.  The default is <code class="docutils literal notranslate"><span class="pre">numpy.float32</span></code> if you don’t specify it.  You can also
optionally provide an initial value for the pixels, which defaults to 0.
The optional <code class="docutils literal notranslate"><span class="pre">xmin,ymin</span></code> allow you to specify the location of the lower-left
pixel, which defaults to (1,1).  Reminder, with our convention for x,y coordinates
described above, ncol is the number of pixels in the x direction, and nrow is the
number of pixels in the y direction.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Image(bounds,</span> <span class="pre">dtype=numpy.float32,</span> <span class="pre">init_value=0,</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>This constructs a new image, allocating memory for the pixel values according to a
given <a class="reference internal" href="#galsim.Bounds" title="galsim.Bounds"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Bounds</span></code></a> object.  Particularly, the bounds should be a <a class="reference internal" href="#galsim.BoundsI" title="galsim.BoundsI"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BoundsI</span></code></a> instance.
You can specify the data type as <code class="docutils literal notranslate"><span class="pre">dtype</span></code> if you want.  The default is
<code class="docutils literal notranslate"><span class="pre">numpy.float32</span></code> if you don’t specify it.  You can also optionally provide an
initial value for the pixels, which defaults to 0.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Image(array,</span> <span class="pre">xmin=1,</span> <span class="pre">ymin=1,</span> <span class="pre">make_const=False,</span> <span class="pre">copy=False</span> <span class="pre">...)</span></code></p>
<blockquote>
<div><p>This views an existing NumPy array as an Image, where updates to either the image
or the original array will affect the other one.  The data type is taken from
<code class="docutils literal notranslate"><span class="pre">array.dtype</span></code>, which must be one of the allowed types listed above.  You can also
optionally set the origin <code class="docutils literal notranslate"><span class="pre">xmin,</span> <span class="pre">ymin</span></code> if you want it to be something other than
(1,1).</p>
<p>You can also optionally force the Image to be read-only with <code class="docutils literal notranslate"><span class="pre">make_const=True</span></code>,
though if the original NumPy array is modified then the contents of <code class="docutils literal notranslate"><span class="pre">Image.array</span></code>
will change.</p>
<p>If you want to make a copy of the input array, rather than just view the existing
array, you can force a copy with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">Image(image,</span> <span class="pre">dtype=image.dtype,</span> <span class="pre">copy=True)</span></code></p>
<blockquote>
<div><p>This creates a copy of an Image, possibly changing the type.  e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_float</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="c1"># default dtype=numpy.float32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_double</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">image_float</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
<p>You can see a list of valid values for dtype in <code class="docutils literal notranslate"><span class="pre">galsim.Image.valid_dtypes</span></code>.
Without the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> argument, this is equivalent to <code class="docutils literal notranslate"><span class="pre">image.copy()</span></code>, which makes
a deep copy.  If you want a copy that shares data with the original, see
the image.view() method.</p>
<p>If you only want to enforce the image to have a given type and not make a copy
if the array is already the correct type, you can use, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_double</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p>You can specify the <code class="docutils literal notranslate"><span class="pre">ncol</span></code>, <code class="docutils literal notranslate"><span class="pre">nrow</span></code>, <code class="docutils literal notranslate"><span class="pre">bounds</span></code>, <code class="docutils literal notranslate"><span class="pre">array</span></code>, or <code class="docutils literal notranslate"><span class="pre">image</span></code>  parameters by
keyword argument if you want, or you can pass them as simple arg as shown aboves, and the
constructor will figure out what they are.</p>
<p>The other keyword arguments (shown as … above) relate to the conversion between sky
coordinates, which is how all the GalSim objects are defined, and the pixel coordinates.
There are three options for this:</p>
<blockquote>
<div><dl class="simple">
<dt>scale</dt><dd><p>You can optionally specify a pixel scale to use.  This would normally have
units arcsec/pixel, but it doesn’t have to be arcsec.  If you want to
use different units for the physical scale of your galsim objects, then
the same unit would be used here.</p>
</dd>
<dt>wcs</dt><dd><p>A WCS object that provides a non-trivial mapping between sky units and
pixel units.  The <code class="docutils literal notranslate"><span class="pre">scale</span></code> parameter is equivalent to
<code class="docutils literal notranslate"><span class="pre">wcs=PixelScale(scale)</span></code>.  But there are a number of more complicated options.
See the WCS class for more details.</p>
</dd>
<dt>None</dt><dd><p>If you do not provide either of the above, then the conversion is undefined.
When drawing onto such an image, a suitable pixel scale will be automatically
set according to the Nyquist scale of the object being drawn.</p>
</dd>
</dl>
</div></blockquote>
<p>After construction, you can set or change the scale or wcs with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">new_scale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">wcs</span> <span class="o">=</span> <span class="n">new_wcs</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">image.scale</span></code> will only work if the WCS is a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>.  Once you set the
wcs to be something non-trivial, then you must interact with it via the <code class="docutils literal notranslate"><span class="pre">wcs</span></code> attribute.
The <code class="docutils literal notranslate"><span class="pre">image.scale</span></code> syntax will raise an exception.</p>
<p>There are also two read-only attributes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">bounds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">array</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">array</span></code> attribute is a NumPy array of the Image’s pixels.  The individual elements in the
array attribute are accessed as <code class="docutils literal notranslate"><span class="pre">image.array[y,x]</span></code>, matching the standard NumPy convention,
while the Image class’s own accessor uses either <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> or <code class="docutils literal notranslate"><span class="pre">[x,y]</span></code>.</p>
<p>That is, the following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">image</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, for setting individual pixel values, the following are equivalent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ixy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ixy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">new_ixy</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt>
<code class="sig-name descname">`view`</code></dt>
<dd><p>Return a view of the image, possibly giving it a new scale or wcs.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.subImage">
<code class="sig-name descname">subImage</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.subImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.subImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a view of a portion of the full image.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.wrap">
<code class="sig-name descname">wrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.wrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap the values in a image onto a given subimage and return the subimage.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.bin">
<code class="sig-name descname">bin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.bin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Bin the image pixels in blocks of nx x ny pixels.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.subsample">
<code class="sig-name descname">subsample</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.subsample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.subsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivide the image pixels into nx x ny sub-pixels.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the origin of the image by (dx,dy).</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setCenter">
<code class="sig-name descname">setCenter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setCenter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setCenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a new position for the center of the image.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setOrigin">
<code class="sig-name descname">setOrigin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setOrigin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setOrigin" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a new position for the origin (x,y) = (0,0) of the image.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.getValue">
<code class="sig-name descname">getValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.getValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of a single pixel.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setValue">
<code class="sig-name descname">setValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of a single pixel.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.addValue">
<code class="sig-name descname">addValue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.addValue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.addValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Add to the value of a single pixel.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.resize">
<code class="sig-name descname">resize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.resize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize the image to have a new bounds.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.fill">
<code class="sig-name descname">fill</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.fill"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the image with the same value in all pixels.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setZero">
<code class="sig-name descname">setZero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setZero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the image with zeros.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.invertSelf">
<code class="sig-name descname">invertSelf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.invertSelf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.invertSelf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert each value x to 1/x.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the image.</p>
</dd></dl>

<p>See their documentation for more details.</p>
<dl class="method">
<dt id="galsim.Image.FindAdaptiveMom">
<code class="sig-name descname">FindAdaptiveMom</code><span class="sig-paren">(</span><em class="sig-param">weight=None</em>, <em class="sig-param">badpix=None</em>, <em class="sig-param">guess_sig=5.0</em>, <em class="sig-param">precision=1e-06</em>, <em class="sig-param">guess_centroid=None</em>, <em class="sig-param">strict=True</em>, <em class="sig-param">round_moments=False</em>, <em class="sig-param">hsmparams=None</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.FindAdaptiveMom" title="Permalink to this definition">¶</a></dt>
<dd><p>Measure adaptive moments of an object.</p>
<p>This method estimates the best-fit elliptical Gaussian to the object (see Hirata &amp; Seljak 2003
for more discussion of adaptive moments).  This elliptical Gaussian is computed iteratively
by initially guessing a circular Gaussian that is used as a weight function, computing the
weighted moments, recomputing the moments using the result of the previous step as the weight
function, and so on until the moments that are measured are the same as those used for the
weight function.  <a class="reference internal" href="#galsim.Image.FindAdaptiveMom" title="galsim.Image.FindAdaptiveMom"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">FindAdaptiveMom</span></code></a> can be used either as a free function, or as a method of the
<a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> class.</p>
<p>This routine assumes that (at least locally) the WCS can be approximated as a <a class="reference internal" href="wcs.html#galsim.PixelScale" title="galsim.PixelScale"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PixelScale</span></code></a>, with
no distortion or non-trivial remapping. Any non-trivial WCS gets completely ignored.</p>
<p>Like <a class="reference internal" href="hsm.html#galsim.hsm.EstimateShear" title="galsim.hsm.EstimateShear"><code class="xref any py py-func docutils literal notranslate"><span class="pre">EstimateShear</span></code></a>, <a class="reference internal" href="#galsim.Image.FindAdaptiveMom" title="galsim.Image.FindAdaptiveMom"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">FindAdaptiveMom</span></code></a> works on <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> inputs, and fails if the object is
small compared to the pixel scale.  For more details, see <a class="reference internal" href="hsm.html#galsim.hsm.EstimateShear" title="galsim.hsm.EstimateShear"><code class="xref any py py-func docutils literal notranslate"><span class="pre">EstimateShear</span></code></a>.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">flux</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian_image</span> <span class="o">=</span> <span class="n">my_gaussian</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;no_pixel&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_moments</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">hsm</span><span class="o">.</span><span class="n">FindAdaptiveMom</span><span class="p">(</span><span class="n">my_gaussian_image</span><span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_moments</span> <span class="o">=</span> <span class="n">my_gaussian_image</span><span class="o">.</span><span class="n">FindAdaptiveMom</span><span class="p">()</span>
</pre></div>
</div>
<p>Assuming a successful measurement, the most relevant pieces of information are
<code class="docutils literal notranslate"><span class="pre">my_moments.moments_sigma</span></code>, which is <code class="docutils literal notranslate"><span class="pre">|det(M)|^(1/4)</span></code> (= <code class="docutils literal notranslate"><span class="pre">sigma</span></code> for a circular Gaussian)
and <code class="docutils literal notranslate"><span class="pre">my_moments.observed_shape</span></code>, which is a <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a>.  In this case,
<code class="docutils literal notranslate"><span class="pre">my_moments.moments_sigma</span></code> is precisely 5.0 (in units of pixels), and
<code class="docutils literal notranslate"><span class="pre">my_moments.observed_shape</span></code> is consistent with zero.</p>
<p>Methods of the <a class="reference internal" href="shear.html#galsim.Shear" title="galsim.Shear"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Shear</span></code></a> class can be used to get the distortion <code class="docutils literal notranslate"><span class="pre">e</span></code>, the shear <code class="docutils literal notranslate"><span class="pre">g</span></code>, the
conformal shear <code class="docutils literal notranslate"><span class="pre">eta</span></code>, and so on.</p>
<p>As an example of how to use the optional <code class="docutils literal notranslate"><span class="pre">hsmparams</span></code> argument, consider cases where the input
images have unusual properties, such as being very large.  This could occur when measuring the
properties of a very over-sampled image such as that generated using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Gaussian</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_gaussian_image</span> <span class="o">=</span> <span class="n">my_gaussian</span><span class="o">.</span><span class="n">drawImage</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;no_pixel&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the user attempts to measure the moments of this very large image using the standard syntax,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_moments</span> <span class="o">=</span> <span class="n">my_gaussian_image</span><span class="o">.</span><span class="n">FindAdaptiveMom</span><span class="p">()</span>
</pre></div>
</div>
<p>then the result will be a <code class="docutils literal notranslate"><span class="pre">GalSimHSMError</span></code> due to moment measurement failing because the
object is so large.  While the list of all possible settings that can be changed is accessible
in the docstring of the <a class="reference internal" href="hsm.html#galsim.hsm.HSMParams" title="galsim.hsm.HSMParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">HSMParams</span></code></a> class, in this case we need to modify <code class="docutils literal notranslate"><span class="pre">max_amoment</span></code> which
is the maximum value of the moments in units of pixel^2.  The following measurement, using the
default values for every parameter except for <code class="docutils literal notranslate"><span class="pre">max_amoment</span></code>, will be
successful:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_params</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">hsm</span><span class="o">.</span><span class="n">HSMParams</span><span class="p">(</span><span class="n">max_amoment</span><span class="o">=</span><span class="mf">5.0e5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_moments</span> <span class="o">=</span> <span class="n">my_gaussian_image</span><span class="o">.</span><span class="n">FindAdaptiveMom</span><span class="p">(</span><span class="n">hsmparams</span><span class="o">=</span><span class="n">new_params</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>object_image</strong> – The <a class="reference internal" href="#galsim.Image" title="galsim.Image"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Image</span></code></a> for the object being measured.</p></li>
<li><p><strong>weight</strong> – The optional weight image for the object being measured.  Can be an int
or a float array.  Currently, GalSim does not account for the variation
in non-zero weights, i.e., a weight map is converted to an image with 0
and 1 for pixels that are not and are used.  Full use of spatial
variation in non-zero weights will be included in a future version of
the code. [default: None]</p></li>
<li><p><strong>badpix</strong> – The optional bad pixel mask for the image being used.  Zero should be
used for pixels that are good, and any nonzero value indicates a bad
pixel. [default: None]</p></li>
<li><p><strong>guess_sig</strong> – Optional argument with an initial guess for the Gaussian sigma of the
object (in pixels). [default: 5.0]</p></li>
<li><p><strong>precision</strong> – The convergence criterion for the moments. [default: 1e-6]</p></li>
<li><p><strong>guess_centroid</strong> – An initial guess for the object centroid (useful in case it is not
located at the center, which is used if this keyword is not set).  The
convention for centroids is such that the center of the lower-left pixel
is (image.xmin, image.ymin).
[default: object_image.true_center]</p></li>
<li><p><strong>strict</strong> – Whether to require success. If <code class="docutils literal notranslate"><span class="pre">strict=True</span></code>, then there will be a
<code class="docutils literal notranslate"><span class="pre">GalSimHSMError</span></code> exception if shear estimation fails.  If set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, then information about failures will be silently stored in
the output ShapeData object. [default: True]</p></li>
<li><p><strong>round_moments</strong> – Use a circular weight function instead of elliptical.
[default: False]</p></li>
<li><p><strong>hsmparams</strong> – The hsmparams keyword can be used to change the settings used by
FindAdaptiveMom when estimating moments; see <a class="reference internal" href="hsm.html#galsim.hsm.HSMParams" title="galsim.hsm.HSMParams"><code class="xref any py py-class docutils literal notranslate"><span class="pre">HSMParams</span></code></a> documentation
for more information. [default: None]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a <a class="reference internal" href="hsm.html#galsim.hsm.ShapeData" title="galsim.hsm.ShapeData"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ShapeData</span></code></a> object containing the results of moment measurement.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.addNoise">
<code class="sig-name descname">addNoise</code><span class="sig-paren">(</span><em class="sig-param">noise</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.addNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add noise to the image according to a supplied noise model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>noise</strong> – The noise (<a class="reference internal" href="noise.html#galsim.BaseNoise" title="galsim.BaseNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseNoise</span></code></a>) model to use.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.addNoiseSNR">
<code class="sig-name descname">addNoiseSNR</code><span class="sig-paren">(</span><em class="sig-param">noise</em>, <em class="sig-param">snr</em>, <em class="sig-param">preserve_flux=False</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.addNoiseSNR" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds noise to the image in a way that achieves the specified signal-to-noise ratio.</p>
<p>The given SNR (<code class="docutils literal notranslate"><span class="pre">snr</span></code>) can be achieved either by scaling the flux of the object while keeping
the noise level fixed, or the flux can be preserved and the noise variance changed.  This is set
using the parameter <code class="docutils literal notranslate"><span class="pre">preserve_flux</span></code>.</p>
<p>The definition of SNR is equivalent to the one used by Great08.  Taking a weighted integral
of the flux</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}S &amp;= \frac{\sum W(x,y) I(x,y)}{\sum W(x,y)} \\
N^2 = Var(S) &amp;= \frac{\sum W(x,y)^2 Var(I(x,y))}{(\sum W(x,y))^2}\end{split}\]</div>
</div></blockquote>
<p>and assuming that Var(I(x,y)) is constant</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[Var(I(x,y)) = noise\_var\]</div>
</div></blockquote>
<p>We then assume that we are using a matched filter for W, so W(x,y) = I(x,y).  Then a few things
cancel and we find that</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[snr = S/N = \sqrt{\frac{\sum I(x,y)^2}{noise\_var}}\]</div>
</div></blockquote>
<p>and therefore, for a given I(x,y) and snr,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[noise\_var = \frac{\sum I(x,y)^2}{snr^2}\]</div>
</div></blockquote>
<p>Note that for noise models such as Poisson and CCDNoise, the constant Var(I(x,y)) assumption
is only approximate, since the flux of the object adds to the Poisson noise in those pixels.
Thus, the real S/N on the final image will be slightly lower than the target <code class="docutils literal notranslate"><span class="pre">snr</span></code> value,
and this effect will be larger for brighter objects.</p>
<p>Also, this function relies on <code class="xref any docutils literal notranslate"><span class="pre">noise.getVariance()</span></code> to determine how much variance the
noise model will add.  Thus, it will not work for noise models that do not have a well-
defined variance, such as <a class="reference internal" href="noise.html#galsim.VariableGaussianNoise" title="galsim.VariableGaussianNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">VariableGaussianNoise</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – The noise (<a class="reference internal" href="noise.html#galsim.BaseNoise" title="galsim.BaseNoise"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BaseNoise</span></code></a>) model to use.</p></li>
<li><p><strong>snr</strong> – The desired signal-to-noise after the noise is applied.</p></li>
<li><p><strong>preserve_flux</strong> – Whether to preserve the flux of the object (<code class="docutils literal notranslate"><span class="pre">True</span></code>) or the variance of
the noise model (<code class="docutils literal notranslate"><span class="pre">False</span></code>) to achieve the desired SNR. [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the variance of the noise that was applied to the image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.addReciprocityFailure">
<code class="sig-name descname">addReciprocityFailure</code><span class="sig-paren">(</span><em class="sig-param">exp_time</em>, <em class="sig-param">alpha</em>, <em class="sig-param">base_flux</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.addReciprocityFailure" title="Permalink to this definition">¶</a></dt>
<dd><p>Accounts for the reciprocity failure and includes it in the original Image directly.</p>
<p>Reciprocity, in the context of photography, is the inverse relationship between the incident
flux (I) of a source object and the exposure time (t) required to produce a given response (p)
in the detector, i.e., p = I*t. At very low (also at high) levels of incident flux, deviation
from this relation is observed, leading to reduced sensitivity at low flux levels. The pixel
response to a high flux is larger than its response to a low flux. This flux-dependent non-
linearity is known as ‘Reciprocity Failure’ and is known to happen in photographic films since
1893. Interested users can refer to <a class="reference external" href="http://en.wikipedia.org/wiki/Reciprocity_(photography">http://en.wikipedia.org/wiki/Reciprocity_(photography</a>)</p>
<p>CCDs are not known to suffer from this effect. HgCdTe detectors that are used for near infrared
astrometry, although to an extent much lesser than the photographic films, are found to
exhibit reciprocity failure at low flux levels. The exact mechanism of this effect is unknown
and hence we lack a good theoretical model. Many models that fit the empirical data exist and
a common relation is</p>
<blockquote>
<div><p>pR/p = (1 + alpha*log10(p/t) - alpha*log10(p’/t’))</p>
</div></blockquote>
<p>where t is the exposure time (in units of seconds), p is the pixel response (in units of
electrons) and pR is the response if the reciprocity relation fails to hold. p’/t’ is count
rate (in electrons/second) corresponding to the photon flux (base flux) at which the detector
is calibrated to have its nominal gain. alpha is the parameter in the model, measured in units
of per decade and varies with detectors and the operating temperature. The functional form for
the reciprocity failure is motivated empirically from the tests carried out on H2RG detectors.
See for reference Fig. 1 and Fig. 2 of <a class="reference external" href="http://arxiv.org/abs/1106.1090">http://arxiv.org/abs/1106.1090</a>. Since pR/p remains
close to unity over a wide range of flux, we convert this relation to a power law by
approximating (pR/p)-1 ~ log(pR/p). This gives a relation that is better behaved than the
logarithmic relation at low flux levels.</p>
<blockquote>
<div><p>pR/p = ((p/t)/(p’/t’))^(alpha/log(10)).</p>
</div></blockquote>
<p>Because of how this function is defined, the input image must have non-negative pixel
values for the resulting image to be well-defined. Negative pixel values result in ‘nan’s.
The image should be in units of electrons, or if it is in ADU, then the value passed to
exp_time should be the exposure time divided by the nominal gain. The image should include
both the signal from the astronomical objects as well as the background level.  The addition of
nonlinearity should occur after including the effect of reciprocity failure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>exp_time</strong> – The exposure time (t) in seconds, which goes into the expression for
reciprocity failure given in the docstring.</p></li>
<li><p><strong>alpha</strong> – The alpha parameter in the expression for reciprocity failure, in
units of ‘per decade’.</p></li>
<li><p><strong>base_flux</strong> – The flux (p’/t’) at which the gain is calibrated to have its nominal
value.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">addValue</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.addValue"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Add some amount to the pixel value at given (x,y) position</p>
<p>The arguments here may be either (x, y, value) or (pos, value) where pos is a PositionI.
Or you can provide x, y, value as named kwargs.</p>
<p>This is equivalent to self[x,y] += rhs</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.applyIPC">
<code class="sig-name descname">applyIPC</code><span class="sig-paren">(</span><em class="sig-param">IPC_kernel</em>, <em class="sig-param">edge_treatment='extend'</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">kernel_nonnegativity=True</em>, <em class="sig-param">kernel_normalization=True</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.applyIPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the effect of interpixel capacitance to the Image instance.</p>
<p>In NIR detectors, the quantity that is sensed is not the charge as in CCDs, but a voltage that
relates to the charge present within each pixel. The voltage read at a given pixel location is
influenced by the charges present in the neighboring pixel locations due to capacitive
coupling of sense nodes.</p>
<p>This interpixel capacitance is approximated as a linear effect that can be described by a 3x3
kernel that is convolved with the image. The kernel must be an Image instance and could be
intrinsically anisotropic. A sensible kernel must have non-negative entries and must be
normalized such that the sum of the elements is 1, in order to conserve the total charge.
The (1,1) element of the kernel is the contribution to the voltage read at a pixel from the
electrons in the pixel to its bottom-left, the (1,2) element of the kernel is the contribution
from the charges to its left and so on.</p>
<p>The argument ‘edge_treatment’ specifies how the edges of the image should be treated, which
could be in one of the three ways:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>‘extend’: The kernel is convolved with the zero-padded image, leading to a larger</dt><dd><p>intermediate image. The central portion of this image is returned.  [default]</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘crop’: The kernel is convolved with the image, with the kernel inside the image completely.</dt><dd><p>Pixels at the edges, where the center of the kernel could not be placed, are set to the
value specified by ‘fill_value’. If ‘fill_value’ is not specified or set to ‘None’, then
the pixel values in the original image are retained. The user can make the edges invalid
by setting fill_value to numpy.nan.</p>
</dd>
</dl>
</li>
<li><p>‘wrap’: The kernel is convolved with the image, assuming periodic boundary conditions.</p></li>
</ol>
<p>The size of the image array remains unchanged in all three cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IPC_kernel</strong> – A 3x3 Image instance that is convolved with the Image instance</p></li>
<li><p><strong>edge_treatment</strong> – Specifies the method of handling edges and should be one of
‘crop’, ‘extend’ or ‘wrap’. See above for details.
[default: ‘extend’]</p></li>
<li><p><strong>fill_value</strong> – Specifies the value (including nan) to fill the edges with when
edge_treatment is ‘crop’. If unspecified or set to ‘None’, the
original pixel values are retained at the edges. If
edge_treatment is not ‘crop’, then this is ignored.</p></li>
<li><p><strong>kernel_nonnegativity</strong> – Specify whether the kernel should have only non-negative
entries.  [default: True]</p></li>
<li><p><strong>kernel_normalization</strong> – Specify whether to check and enforce correct normalization for
the kernel.  [default: True]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.applyNonlinearity">
<code class="sig-name descname">applyNonlinearity</code><span class="sig-paren">(</span><em class="sig-param">NLfunc</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.applyNonlinearity" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the given non-linearity function (<code class="docutils literal notranslate"><span class="pre">NLfunc</span></code>) on the Image instance directly.</p>
<p>This routine can transform the image in a non-linear manner specified by the user. However,
the typical kind of non-linearity one sees in astronomical images is voltage non-linearity,
also sometimes known as ‘classical non-linearity’, refers to the non-linearity in
charge-to-voltage conversion process. This arises as charge gets integrated at the junction
capacitance of the pixel node. Voltage non-linearity decreases signals at higher signal
levels, causing the attenuation of brighter pixels. The image should include both the
signal from the astronomical objects as well as the background level. Other detectors effects
such as dark current and persistence (not currently included in GalSim) would also occur
before the inclusion of nonlinearity.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">NLfunc</span></code> is a callable function (for example a lambda function, a
galsim.LookupTable, or a user-defined function), possibly with arguments that need to be given
as subsequent arguments to the <code class="docutils literal notranslate"><span class="pre">applyNonlinearity</span></code> function (after the <code class="docutils literal notranslate"><span class="pre">NLfunc</span></code> argument).
<code class="docutils literal notranslate"><span class="pre">NLfunc</span></code> should be able to take a 2d NumPy array as input, and return a NumPy array of the
same shape.  It should be defined such that it outputs the final image with nonlinearity
included (i.e., in the limit that there is no nonlinearity, the function should return the
original image, NOT zero). The image should be in units of electrons when this routine is being
used to generate classical non-linearity. When used for other purposes, the units can be in
electrons or in ADU, as found appropriate by the user.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.e-7</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">applyNonlinearity</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">beta1</span><span class="p">,</span> <span class="n">beta2</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">beta1</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">beta2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">applyNonlinearity</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.e-7</span><span class="p">,</span> <span class="mf">1.e-10</span><span class="p">)</span>
</pre></div>
</div>
<p>On calling the method, the Image instance <code class="docutils literal notranslate"><span class="pre">img</span></code> is transformed by the user-defined function
<code class="docutils literal notranslate"><span class="pre">f</span></code> with <code class="docutils literal notranslate"><span class="pre">beta1</span></code> = 1.e-7 and <code class="docutils literal notranslate"><span class="pre">beta2</span></code> = 1.e-10.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>NLfunc</strong> – The function that maps the input image pixel values to the output image pixel
values.</p></li>
<li><p><strong>*args</strong> – Any subsequent arguments are passed along to the NLfunc function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.applyPersistence">
<code class="sig-name descname">applyPersistence</code><span class="sig-paren">(</span><em class="sig-param">imgs</em>, <em class="sig-param">coeffs</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.applyPersistence" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the effects of persistence to the Image instance.</p>
<p>Persistence refers to the retention of a small fraction of the signal after resetting the
imager pixel elements. The persistence signal of a previous exposure is left in the pixel even
after several detector resets. This effect is most likely due to charge traps in the material.
Laboratory tests on the WFIRST CMOS detectors show that if exposures and readouts are taken in
a fixed cadence, the persistence signal can be given as a linear combination of prior pixel
values that can be added to the current image.</p>
<p>This routine takes in a list of Image instances and adds them to Image weighted by the values
passed on to ‘coeffs’. The pixel values of the Image instances in the list must correspond to
the electron counts before the readout. This routine does NOT keep track of realistic dither
patterns. During the image simulation process, the user has to queue a list of previous Image
instances (imgs) outside the routine by inserting the latest image in the beginning of the list
and deleting the oldest image. The values in ‘coeffs’ tell how much of each Image is to be
added. This usually remains constant in the image generation process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgs</strong> – A list of previous Image instances that still persist.</p></li>
<li><p><strong>coeffs</strong> – A list of floats that specifies the retention factors for the corresponding
Image instances listed in ‘imgs’.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">bin</code><span class="sig-paren">(</span><em class="sig-param">nx</em>, <em class="sig-param">ny</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.bin"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Bin the image pixels in blocks of nx x ny pixels.</p>
<p>This returns a new image that is a binned version of the current image.
Adjacent pixel values in nx x ny blocks are added together to produce the flux in each
output pixel.</p>
<p>If the current number of pixels in each direction is not a multiple of nx, ny, then the
last pixel in each direction will be the sum of fewer than nx or ny pixels as needed.</p>
<p>See also subsample, which is the opposite of this.</p>
<p>If the wcs is a Jacobian (or simpler), the output image will have its wcs set properly.
But if the wcs is more complicated, the output wcs would be fairly complicated to figure
out properly, so we leave it as None.  The user should set it themselves if required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – The number of adjacent pixels in the x direction to add together into each
output pixel.</p></li>
<li><p><strong>ny</strong> – The number of adjacent pixels in the y direction to add together into each
output pixel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new Image</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculateFWHM">
<code class="sig-name descname">calculateFWHM</code><span class="sig-paren">(</span><em class="sig-param">center=None</em>, <em class="sig-param">Imax=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculateFWHM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculateFWHM" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the full-width half-maximum (FWHM) of a drawn object.</p>
<p>This method is equivalent to GSObject.calculateFWHM when the object has already
been drawn onto an image.  Note that the profile should be drawn using a method that
does not integrate over pixels, so either ‘sb’ or ‘no_pixel’.  Also, if there is a
significant amount of noise in the image, this method may not work well.</p>
<p>If the image has a wcs other than a PixelScale, an AttributeError will be raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> – The position in pixels to use for the center, r=0.
[default: self.true_center]</p></li>
<li><p><strong>Imax</strong> – The maximum surface brightness.  [default: max(self.array)]
Note: If Imax is provided, and the maximum pixel value is larger than
this value, Imax will be updated to use the larger value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an estimate of the full-width half-maximum in physical units defined by the pixel scale.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculateHLR">
<code class="sig-name descname">calculateHLR</code><span class="sig-paren">(</span><em class="sig-param">center=None</em>, <em class="sig-param">flux=None</em>, <em class="sig-param">flux_frac=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculateHLR"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculateHLR" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the half-light radius of a drawn object.</p>
<p>This method is equivalent to GSObject.calculateHLR when the object has already been
been drawn onto an image.  Note that the profile should be drawn using a method that
integrates over pixels and does not add noise. (The default method=’auto’ is acceptable.)</p>
<p>If the image has a wcs other than a PixelScale, an AttributeError will be raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> – The position in pixels to use for the center, r=0.
[default: self.true_center]</p></li>
<li><p><strong>flux</strong> – The total flux.  [default: sum(self.array)]</p></li>
<li><p><strong>flux_frac</strong> – The fraction of light to be enclosed by the returned radius.
[default: 0.5]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an estimate of the half-light radius in physical units defined by the pixel scale.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculateMomentRadius">
<code class="sig-name descname">calculateMomentRadius</code><span class="sig-paren">(</span><em class="sig-param">center=None</em>, <em class="sig-param">flux=None</em>, <em class="sig-param">rtype='det'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculateMomentRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculateMomentRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an estimate of the radius based on unweighted second moments of a drawn object.</p>
<p>This method is equivalent to GSObject.calculateMomentRadius when the object has already
been drawn onto an image.  Note that the profile should be drawn using a method that
integrates over pixels and does not add noise. (The default method=’auto’ is acceptable.)</p>
<p>If the image has a wcs other than a PixelScale, an AttributeError will be raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> – The position in pixels to use for the center, r=0.
[default: self.true_center]</p></li>
<li><p><strong>flux</strong> – The total flux.  [default: sum(self.array)]</p></li>
<li><p><strong>rtype</strong> – <p>There are three options for this parameter:</p>
<ul>
<li><p>’trace’ means return sqrt(T/2)</p></li>
<li><p>’det’ means return det(Q)^1/4</p></li>
<li><p>’both’ means return both: (sqrt(T/2), det(Q)^1/4)</p></li>
</ul>
<p>[default: ‘det’]</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an estimate of the radius in physical units defined by the pixel scale
(or both estimates if rtype == ‘both’).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculate_fft">
<code class="sig-name descname">calculate_fft</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculate_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculate_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an FFT of an Image in real space to produce a k-space Image.</p>
<p>Note: the image will be padded with zeros as needed to make an image with bounds that
look like BoundsI(-N/2, N/2-1, -N/2, N/2-1).</p>
<p>The input image must have a PixelScale wcs.  The output image will be complex (an ImageCF
or ImageCD instance) and its scale will be 2pi / (N dx), where dx is the scale of the input
image.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an Image instance with the k-space image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.calculate_inverse_fft">
<code class="sig-name descname">calculate_inverse_fft</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.calculate_inverse_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.calculate_inverse_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an inverse FFT of an Image in k-space to produce a real-space Image.</p>
<p>The starting image is typically an ImageCD, although if the Fourier function is real valued,
then you could get away with using an ImageD or ImageF.</p>
<p>The image is assumed to be Hermitian.  In fact, only the portion with x &gt;= 0 needs to
be defined, with f(-x,-y) taken to be conj(f(x,y)).</p>
<p>Note: the k-space image will be padded with zeros and/or wrapped as needed to make an
image with bounds that look like BoundsI(0, N/2, -N/2, N/2-1).  If you are building a
larger k-space image and then wrapping, you should wrap directly into an image of
this shape.</p>
<p>The input image must have a PixelScale wcs.  The output image will be real (an ImageD
instance) and its scale will be 2pi / (N dk), where dk is the scale of the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an ImageD instance with the real-space image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.center">
<em class="property">property </em><code class="sig-name descname">center</code><a class="headerlink" href="#galsim.Image.center" title="Permalink to this definition">¶</a></dt>
<dd><p>The current nominal center (xcen,ycen) of the image as a PositionI instance.</p>
<p>In terms of the rows and columns, xcen is the x value for the central column, and ycen
is the y value of the central row.  For even-sized arrays, there is no central column
or row, so the convention we adopt in this case is to round up.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">center</span>
<span class="go">galsim.PositionI(x=3, y=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span><span class="mi">72</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">center</span>
<span class="go">galsim.PositionI(x=56, y=72)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
<span class="go">10.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.conjugate">
<em class="property">property </em><code class="sig-name descname">conjugate</code><a class="headerlink" href="#galsim.Image.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex conjugate of an image.</p>
<p>This works for real or complex.  For real images, it acts the same as view().</p>
<p>Note that for complex images, this is not a conjugate view into the original image.
So changing the original image does not change the conjugate (or vice versa).</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.copyFrom">
<code class="sig-name descname">copyFrom</code><span class="sig-paren">(</span><em class="sig-param">rhs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.copyFrom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.copyFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the contents of another image</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">fill</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.fill"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Set all pixel values to the given <code class="docutils literal notranslate"><span class="pre">value</span></code></p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">getValue</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.getValue"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>This method is a synonym for im(x,y).  It is a bit faster than im(x,y), since GalSim
does not have to parse the different options available for __call__.  (i.e. im(x,y) or
im(pos) or im(x=x,y=y))</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.good_fft_size">
<em class="property">classmethod </em><code class="sig-name descname">good_fft_size</code><span class="sig-paren">(</span><em class="sig-param">input_size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.good_fft_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.good_fft_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Round the given input size up to the next higher power of 2 or 3 times a power of 2.</p>
<p>This rounds up to the next higher value that is either 2^k or 3*2^k.  If you are
going to be performing FFTs on an image, these will tend to be faster at performing
the FFT.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.imag">
<em class="property">property </em><code class="sig-name descname">imag</code><a class="headerlink" href="#galsim.Image.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part of an image.</p>
<p>This is a property, not a function.  So im.imag, not im.imag().</p>
<p>This works for real or complex.  For real images, the returned array is read-only and
all elements are 0.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">invertSelf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.invertSelf"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Set all pixel values to their inverse: x -&gt; 1/x.</p>
<p>Note: any pixels whose value is 0 originally are ignored.  They remain equal to 0
on the output, rather than turning into inf.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.iscontiguous">
<em class="property">property </em><code class="sig-name descname">iscontiguous</code><a class="headerlink" href="#galsim.Image.iscontiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates whether each row of the image is contiguous in memory.</p>
<p>Note: it is ok for the end of one row to not be contiguous with the start of the
next row.  This just checks that each individual row has a stride of 1.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.Image.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the origin of the image.  i.e. the (x,y) position of the lower-left pixel.</p>
<p>In terms of the rows and columns, this is the (x,y) coordinate of the first column, and
first row of the array.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">origin</span>
<span class="go">galsim.PositionI(x=1, y=1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">45</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">origin</span>
<span class="go">galsim.PositionI(x=23, y=45)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">45</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">bounds</span>
<span class="go">galsim.BoundsI(xmin=23, xmax=26, ymin=45, ymax=48)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.outer_bounds">
<em class="property">property </em><code class="sig-name descname">outer_bounds</code><a class="headerlink" href="#galsim.Image.outer_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>The bounds of the outer edge of the pixels.</p>
<p>Equivalent to galsim.BoundsD(im.xmin-0.5, im.xmax+0.5, im.ymin-0.5, im.ymax+0.5)</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.quantize">
<code class="sig-name descname">quantize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.quantize" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds the pixel values in an image to integer values, while preserving the type of the data.</p>
<p>At certain stages in the astronomical image generation process, detectors effectively round to
the nearest integer.  The exact stage at which this happens depends on the type of device (CCD
vs. NIR detector).  For example, for H2RG detectors, quantization happens in two stages: first,
when detecting a certain number of photons, corresponding to the sum of background and signal
multiplied by the QE and including reciprocity failure.  After this, a number of other processes
occur (e.g., nonlinearity, IPC, read noise) that could result in non-integer pixel values, only
rounding to an integer at the stage of analog-to-digital conversion.</p>
<p>Because we cannot guarantee that quantization will always be the last step in the process, the
quantize() routine does not actually modify the type of the image to ‘int’.  However, users can
easily do so by doing</p>
<blockquote>
<div><p>image.quantize()
int_image = galsim.Image(image, dtype=int)</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.real">
<em class="property">property </em><code class="sig-name descname">real</code><a class="headerlink" href="#galsim.Image.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part of an image.</p>
<p>This is a property, not a function.  So im.real, not im.real().</p>
<p>This works for real or complex.  For real images, it acts the same as view().</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.replaceNegative">
<code class="sig-name descname">replaceNegative</code><span class="sig-paren">(</span><em class="sig-param">replace_value=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.replaceNegative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.replaceNegative" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace any negative values currently in the image with 0 (or some other value).</p>
<p>Sometimes FFT drawing can result in tiny negative values, which may be undesirable for
some purposes.  This method replaces those values with 0 or some other value if desired.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>replace_value</strong> – The value with which to replace any negative pixels. [default: 0]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">resize</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">wcs=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.resize"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Resize the image to have a new bounds (must be a BoundsI instance)</p>
<p>Note that the resized image will have uninitialized data.  If you want to preserve
the existing data values, you should either use <code class="docutils literal notranslate"><span class="pre">subImage</span></code> (if you want a smaller
portion of the current Image) or make a new Image and copy over the current values
into a portion of the new image (if you are resizing to a larger Image).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – The new bounds to resize to.</p></li>
<li><p><strong>wcs</strong> – If provided, also update the wcs to the given value. [default: None,
which means keep the existing wcs]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">setCenter</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setCenter"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Set the center of the image to the given (integral) (xcen, ycen)</p>
<p>The arguments here may be either (xcen, ycen) or a PositionI instance.
Or you can provide xcen, ycen as named kwargs.</p>
<p>In terms of the rows and columns, xcen is the new x value for the central column, and ycen
is the new y value of the central row.  For even-sized arrays, there is no central column
or row, so the convention we adopt in this case is to round up.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">15.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">15.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">234</span><span class="p">,</span><span class="mi">456</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">234</span><span class="p">,</span><span class="mi">456</span><span class="p">)</span>
<span class="go">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">bounds</span>
<span class="go">galsim.BoundsI(xmin=232, xmax=235, ymin=454, ymax=457)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">setOrigin</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setOrigin"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Set the origin of the image to the given (integral) (x0, y0)</p>
<p>The arguments here may be either (x0, y0) or a PositionI instance.
Or you can provide x0, y0 as named kwargs.</p>
<p>In terms of the rows and columns, x0 is the new x value for the first column,
and y0 is the new y value of the first row.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">12.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="go">15.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">12.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">15.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="mi">234</span><span class="p">,</span><span class="mi">456</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">(</span><span class="mi">234</span><span class="p">,</span><span class="mi">456</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">bounds</span>
<span class="go">galsim.BoundsI(xmin=234, xmax=237, ymin=456, ymax=459)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.setSubImage">
<code class="sig-name descname">setSubImage</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">rhs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setSubImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.setSubImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a portion of the full image to the values in another image</p>
<p>This is equivalent to self[bounds] = rhs</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">setValue</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setValue"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Set the pixel value at given (x,y) position</p>
<p>The arguments here may be either (x, y, value) or (pos, value) where pos is a PositionI.
Or you can provide x, y, value as named kwargs.</p>
<p>This is equivalent to self[x,y] = rhs</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">setZero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.setZero"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Set all pixel values to zero.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.shift"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Shift the pixel coordinates by some (integral) dx,dy.</p>
<p>The arguments here may be either (dx, dy) or a PositionI instance.
Or you can provide dx, dy as named kwargs.</p>
<p>In terms of columns and rows, dx means a shift in the x value of each column in the
array, and dy means a shift in the y value of each row.  In other words, the following
will return the same value for ixy.  The shift function just changes the coordinates (x,y)
used for that pixel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixy</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">subImage</code><span class="sig-paren">(</span><em class="sig-param">bounds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.subImage"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Return a view of a portion of the full image</p>
<p>This is equivalent to self[bounds]</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">subsample</code><span class="sig-paren">(</span><em class="sig-param">nx</em>, <em class="sig-param">ny</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.subsample"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Subdivide the image pixels into nx x ny sub-pixels.</p>
<p>This returns a new image that is a subsampled version of the current image.
Each pixel’s flux is split (uniformly) into nx x ny smaller pixels.</p>
<p>See also bin, which is the opposite of this.  Note that subsample(nx,ny) followed by
bin(nx,ny) is essentially a no op.</p>
<p>If the wcs is a Jacobian (or simpler), the output image will have its wcs set properly.
But if the wcs is more complicated, the output wcs would be fairly complicated to figure
out properly, so we leave it as None.  The user should set it themselves if required.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nx</strong> – The number of sub-pixels in the x direction for each original pixel.</p></li>
<li><p><strong>ny</strong> – The number of sub-pixels in the y direction for each original pixel.</p></li>
<li><p><strong>dtype</strong> – Optionally provide a dtype for the return image. [default: None, which
means to use the same dtype as the original image]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a new Image</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.symmetrizeNoise">
<code class="sig-name descname">symmetrizeNoise</code><span class="sig-paren">(</span><em class="sig-param">noise</em>, <em class="sig-param">order=4</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.symmetrizeNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Impose N-fold symmetry (where N=``order`` is an even integer &gt;=4) on the noise in a square
image assuming that the noise currently in the image can be described by the CorrelatedNoise
object <code class="docutils literal notranslate"><span class="pre">noise</span></code>.  See CorrelatedNoise.symmetrizeImage() docstring for more details of how this
method works.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – The CorrelatedNoise model to use when figuring out how much noise to add to
make the final noise have symmetry at the desired order.</p></li>
<li><p><strong>order</strong> – Desired symmetry order.  Must be an even integer larger than 2.
[default: 4]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the theoretically calculated variance of the combined noise fields in the updated image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.true_center">
<em class="property">property </em><code class="sig-name descname">true_center</code><a class="headerlink" href="#galsim.Image.true_center" title="Permalink to this definition">¶</a></dt>
<dd><p>The current true center of the image as a PositionD instance.</p>
<p>Unline the nominal center returned by im.center, this value may be half-way between
two pixels if the image has an even number of rows or columns.  It gives the position
(x,y) at the exact center of the image, regardless of whether this is at the center of
a pixel (integer value) or halfway between two (half-integer).  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">center</span>
<span class="go">galsim.PositionI(x=3, y=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">true_center</span>
<span class="go">galsim.PositionI(x=2.5, y=2.5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setCenter</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span><span class="mi">72</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">center</span>
<span class="go">galsim.PositionI(x=56, y=72)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">true_center</span>
<span class="go">galsim.PositionD(x=55.5, y=71.5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">setOrigin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="o">.</span><span class="n">true_center</span>
<span class="go">galsim.PositionD(x=1.5, y=1.5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.view">
<code class="sig-name descname">view</code><span class="sig-paren">(</span><em class="sig-param">scale=None</em>, <em class="sig-param">wcs=None</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">center=None</em>, <em class="sig-param">make_const=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.view"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Image.view" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a view of this image, which lets you change the scale, wcs, origin, etc.
but view the same underlying data as the original image.</p>
<p>If you do not provide either <code class="docutils literal notranslate"><span class="pre">scale</span></code> or <code class="docutils literal notranslate"><span class="pre">wcs</span></code>, the view will keep the same wcs
as the current Image object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> – If provided, use this as the pixel scale for the image. [default: None]</p></li>
<li><p><strong>wcs</strong> – If provided, use this as the wcs for the image. [default: None]</p></li>
<li><p><strong>origin</strong> – If profided, use this as the origin position of the view.
[default: None]</p></li>
<li><p><strong>center</strong> – If profided, use this as the center position of the view.
[default: None]</p></li>
<li><p><strong>make_const</strong> – Make the view’s data array immutable. [default: False]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.whitenNoise">
<code class="sig-name descname">whitenNoise</code><span class="sig-paren">(</span><em class="sig-param">noise</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.whitenNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Whiten the noise in the image assuming that the noise currently in the image can be described
by the CorrelatedNoise object <code class="docutils literal notranslate"><span class="pre">noise</span></code>.  See CorrelatedNoise.whitenImage() docstring for more
details of how this method works.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>noise</strong> – The CorrelatedNoise model to use when figuring out how much noise to add to
make the final noise white.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the theoretically calculated variance of the combined noise fields in the updated image.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">wrap</code><span class="sig-paren">(</span><em class="sig-param">bounds</em>, <em class="sig-param">hermitian=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#Image.wrap"><span class="viewcode-link">[source]</span></a></dt>
<dd><p>Wrap the values in a image onto a given subimage and return the subimage.</p>
<p>This would typically be used on a k-space image where you initially draw a larger image
than you want for the FFT and then wrap it onto a smaller subset.  This will cause
aliasing of course, but this is often preferable to just using the smaller image
without wrapping.</p>
<p>For complex images of FFTs, one often only stores half the image plane with the
implicit understanding that the function is Hermitian, so im(-x,-y) == im(x,y).conjugate().
In this case, the wrapping needs to work slightly differently, so you can specify
that your image is implicitly Hermitian with the <code class="docutils literal notranslate"><span class="pre">hermitian</span></code> argument.  Options are:</p>
<ul class="simple">
<li><p>hermitian=False  (default) Normal non-Hermitian image.</p></li>
<li><dl class="simple">
<dt>hermitian=’x’    Only x&gt;=0 values are stored with x&lt;0 values being implicitly Hermitian.</dt><dd><p>In this case im.bounds.xmin and bounds.xmin must be 0.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>hermitian=’y’    Only y&gt;=0 values are stored with y&lt;0 values being implicitly Hermitian.</dt><dd><p>In this case im.bounds.ymin and bounds.ymin must be 0.</p>
</dd>
</dl>
</li>
</ul>
<p>Also, in the two Hermitian cases, the direction that is not implicitly Hermitian must be
symmetric in the image’s bounds.  The wrap bounds must be almost symmetric, but missing
the most negative value.  For example,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im_full</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">ImageCD</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">scale</span><span class="o">=</span><span class="n">dk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ... fill with im[i,j] = FT(kx=i*dk, ky=j*dk)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N2</span> <span class="o">=</span> <span class="mi">64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im_wrap</span> <span class="o">=</span> <span class="n">im_full</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">N2</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">N2</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This sets up im_wrap to be the properly Hermitian version of the data appropriate for
passing to an FFT.</p>
<p>Note that this routine modifies the original image (and not just the subimage onto which
it is wrapped), so if you want to keep the original pristine, you should call
<code class="docutils literal notranslate"><span class="pre">wrapped_image</span> <span class="pre">=</span> <span class="pre">image.copy().wrap(bounds)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> – The bounds of the subimage onto which to wrap the full image.</p></li>
<li><p><strong>hermitian</strong> – Whether the image is implicitly Hermitian and if so, whether it is the
x or y values that are not stored.  [default: False]</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the subimage, image[bounds], after doing the wrapping.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="galsim.Image.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">file_name=None</em>, <em class="sig-param">dir=None</em>, <em class="sig-param">hdu_list=None</em>, <em class="sig-param">clobber=True</em>, <em class="sig-param">compression='auto'</em><span class="sig-paren">)</span><a class="headerlink" href="#galsim.Image.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a single image to a FITS file.</p>
<p>Write the Image instance <code class="docutils literal notranslate"><span class="pre">image</span></code> to a FITS file, with details depending on the arguments.
This function can be called directly as <code class="docutils literal notranslate"><span class="pre">galsim.fits.write(image,</span> <span class="pre">...)</span></code>, with the image as the
first argument, or as an image method: <code class="docutils literal notranslate"><span class="pre">image.write(...)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> – The image to write to file.  Per the description of this method, it may be
given explicitly via <code class="docutils literal notranslate"><span class="pre">galsim.fits.write(image,</span> <span class="pre">...)</span></code> or the method may be
called directly as an image method, <code class="docutils literal notranslate"><span class="pre">image.write(...)</span></code>.  Note that if the
image has a ‘header’ attribute containing a FitsHeader, then the FitsHeader
is written to the header in the PrimaryHDU, followed by the WCS as usual.</p></li>
<li><p><strong>file_name</strong> – The name of the file to write to.  [Either <code class="docutils literal notranslate"><span class="pre">file_name</span></code> or <code class="docutils literal notranslate"><span class="pre">hdu_list</span></code> is
required.]</p></li>
<li><p><strong>dir</strong> – Optionally a directory name can be provided if <code class="docutils literal notranslate"><span class="pre">file_name</span></code> does not
already include it. [default: None]</p></li>
<li><p><strong>hdu_list</strong> – A pyfits HDUList.  If this is provided instead of <code class="docutils literal notranslate"><span class="pre">file_name</span></code>, then the
image is appended to the end of the HDUList as a new HDU. In that case,
the user is responsible for calling either <code class="docutils literal notranslate"><span class="pre">hdu_list.writeto(...)</span></code> or
<code class="docutils literal notranslate"><span class="pre">galsim.fits.writeFile(...)</span></code> afterwards.  [Either <code class="docutils literal notranslate"><span class="pre">file_name</span></code> or
<code class="docutils literal notranslate"><span class="pre">hdu_list</span></code> is required.]</p></li>
<li><p><strong>clobber</strong> – Setting <code class="docutils literal notranslate"><span class="pre">clobber=True</span></code> when <code class="docutils literal notranslate"><span class="pre">file_name</span></code> is given will silently overwrite
existing files. [default: True]</p></li>
<li><p><strong>compression</strong> – <p>Which compression scheme to use (if any).  Options are:</p>
<ul>
<li><p>None or ‘none’ = no compression</p></li>
<li><p>’rice’ = use rice compression in tiles (preserves header readability)</p></li>
<li><p>’gzip’ = use gzip to compress the full file</p></li>
<li><p>’bzip2’ = use bzip2 to compress the full file</p></li>
<li><p>’gzip_tile’ = use gzip in tiles (preserves header readability)</p></li>
<li><p>’hcompress’ = use hcompress in tiles (only valid for 2-d images)</p></li>
<li><p>’plio’ = use plio compression in tiles (only valid for pos integer data)</p></li>
<li><dl class="simple">
<dt>’auto’ = determine the compression from the extension of the file name</dt><dd><p>(requires <code class="docutils literal notranslate"><span class="pre">file_name</span></code> to be given):
- ‘.fz’ =&gt; ‘rice’
- ‘.gz’ =&gt; ‘gzip’
- ‘.bz2’ =&gt; ‘bzip2’
- otherwise None</p>
</dd>
</dl>
</li>
</ul>
<p>[default: ‘auto’]</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="galsim._Image">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">_Image</code><span class="sig-paren">(</span><em class="sig-param">array</em>, <em class="sig-param">bounds</em>, <em class="sig-param">wcs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#_Image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim._Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to Image(array, bounds, wcs), but without the overhead of sanity checks,
and the other options for how to provide the arguments.</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageF">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageF</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageF" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.float32)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageD">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageD</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageD" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.float64)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageI">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageI</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageI" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.int32)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageS">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageS</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageS" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.int16)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageUI">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageUI</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageUI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.uint32)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageUS">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageUS</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageUS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageUS" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.uint16)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageCF">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageCF</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageCF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.complex64)</p>
</dd></dl>

<dl class="function">
<dt id="galsim.ImageCD">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">ImageCD</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/image.html#ImageCD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.ImageCD" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for galsim.Image(…, dtype=numpy.complex128)</p>
</dd></dl>

</div>
<div class="section" id="bounding-boxes">
<h2>Bounding boxes<a class="headerlink" href="#bounding-boxes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.Bounds">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">Bounds</code><a class="reference internal" href="_modules/galsim/bounds.html#Bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for representing image bounds as 2D rectangles.</p>
<p>Bounds is a base class for two slightly different kinds of bounds:
BoundsD describes bounds with floating point values in x and y.
BoundsI described bounds with integer values in x and y.</p>
<p>The bounds are stored as four numbers in each instance, (xmin, xmax, ymin, ymax), with an
additional boolean switch to say whether or not the Bounds rectangle has been defined.  The
rectangle is undefined if the min value &gt; the max value in either direction.</p>
<p>Initialization:</p>
<p>A BoundsI or BoundsD instance can be initialized in a variety of ways.  The most direct is via
four scalars:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsD</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span><span class="p">)</span>
</pre></div>
</div>
<p>In the BoundsI example above, <code class="docutils literal notranslate"><span class="pre">imin</span></code>, <code class="docutils literal notranslate"><span class="pre">imax</span></code>, <code class="docutils literal notranslate"><span class="pre">jmin</span></code> and <code class="docutils literal notranslate"><span class="pre">jmax</span></code> must all be integers
to avoid a TypeError exception.</p>
<p>Another way to initialize a Bounds instance is using two PositionI/D instances, the first
for <code class="docutils literal notranslate"><span class="pre">(xmin,ymin)</span></code> and the second for <code class="docutils literal notranslate"><span class="pre">(xmax,ymax)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsD</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">PositionI</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">jmin</span><span class="p">),</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionI</span><span class="p">(</span><span class="n">imax</span><span class="p">,</span> <span class="n">jmax</span><span class="p">))</span>
</pre></div>
</div>
<p>In both the examples above, the I/D type of PositionI/D must match that of BoundsI/D.</p>
<p>Finally, there are a two ways to lazily initialize a bounds instance with <code class="docutils literal notranslate"><span class="pre">xmin</span> <span class="pre">=</span> <span class="pre">xmax</span></code>,
<code class="docutils literal notranslate"><span class="pre">ymin</span> <span class="pre">=</span> <span class="pre">ymax</span></code>, which will have an undefined rectangle and the instance method isDefined()
will return False.  The first sets <code class="docutils literal notranslate"><span class="pre">xmin</span> <span class="pre">=</span> <span class="pre">xmax</span> <span class="pre">=</span> <span class="pre">ymin</span> <span class="pre">=</span> <span class="pre">ymax</span> <span class="pre">=</span> <span class="pre">0</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsD</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">()</span>
</pre></div>
</div>
<p>The second method sets both upper and lower rectangle bounds to be equal to some position:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsD</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsI</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">PositionI</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">jmin</span><span class="p">))</span>
</pre></div>
</div>
<p>Once again, the I/D type of PositionI/D must match that of BoundsI/D.</p>
<p>For the latter two initializations, you would typically then add to the bounds with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">+=</span> <span class="n">pos1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">+=</span> <span class="n">pos2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">etc</span><span class="o">.</span><span class="p">]</span>
</pre></div>
</div>
<p>Then the bounds will end up as the bounding box of all the positions that were added to it.</p>
<p>You can also find the intersection of two bounds with the &amp; operator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">overlap</span> <span class="o">=</span> <span class="n">bounds1</span> <span class="o">&amp;</span> <span class="n">bounds2</span>
</pre></div>
</div>
<p>This is useful for adding one image to another when part of the first image might fall off
the edge of the other image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">overlap</span> <span class="o">=</span> <span class="n">stamp</span><span class="o">.</span><span class="n">bounds</span> <span class="o">&amp;</span> <span class="n">image</span><span class="o">.</span><span class="n">bounds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="n">overlap</span><span class="p">]</span> <span class="o">+=</span> <span class="n">stamp</span><span class="p">[</span><span class="n">overlap</span><span class="p">]</span>
</pre></div>
</div>
<dl class="method">
<dt id="galsim.Bounds.area">
<code class="sig-name descname">area</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the area of the enclosed region.</p>
<p>The area is a bit different for integer-type BoundsI and float-type BoundsD instances.
For floating point types, it is simply <code class="docutils literal notranslate"><span class="pre">(xmax-xmin)*(ymax-ymin)</span></code>.  However, for integer
types, we add 1 to each size to correctly count the number of pixels being described by the
bounding box.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.center">
<em class="property">property </em><code class="sig-name descname">center</code><a class="headerlink" href="#galsim.Bounds.center" title="Permalink to this definition">¶</a></dt>
<dd><p>The central position of the Bounds.</p>
<p>For a BoundsI, this will return an integer PositionI, which will be above and/or to
the right of the true center if the x or y ranges have an even number of pixels.</p>
<p>For a BoundsD, this is equivalent to true_center.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.expand">
<code class="sig-name descname">expand</code><span class="sig-paren">(</span><em class="sig-param">factor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Grow the Bounds by the supplied factor about the center.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.getXMax">
<code class="sig-name descname">getXMax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.getXMax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.getXMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of xmax.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.getXMin">
<code class="sig-name descname">getXMin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.getXMin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.getXMin" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of xmin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.getYMax">
<code class="sig-name descname">getYMax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.getYMax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.getYMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of ymax.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.getYMin">
<code class="sig-name descname">getYMin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.getYMin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.getYMin" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of ymin.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.includes">
<code class="sig-name descname">includes</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.includes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.includes" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether a supplied <code class="docutils literal notranslate"><span class="pre">(x,y)</span></code> pair, Position, or Bounds lie within a defined Bounds
rectangle of this instance.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">BoundsD</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">100.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">100.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="mf">50.</span><span class="p">,</span> <span class="mf">50.</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="mf">50.</span><span class="p">,</span> <span class="mf">50.</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">BoundsD</span><span class="p">(</span><span class="o">-</span><span class="mf">50.</span><span class="p">,</span> <span class="o">-</span><span class="mf">50.</span><span class="p">,</span> <span class="mf">150.</span><span class="p">,</span> <span class="mf">150.</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The type of the PositionI/D and BoundsI/D instances (i.e. integer or float type) should
match that of the bounds instance.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.isDefined">
<code class="sig-name descname">isDefined</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.isDefined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.isDefined" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether Bounds rectangle is defined.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.origin">
<em class="property">property </em><code class="sig-name descname">origin</code><a class="headerlink" href="#galsim.Bounds.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>The lower left position of the Bounds.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">delta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the Bounds instance by a supplied position</p>
<p>Examples:</p>
<p>The shift method takes either a PositionI or PositionD instance, which must match
the type of the Bounds instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">BoundsI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">PositionI</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">BoundsD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">37.4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">49.9</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="mf">3.9</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.true_center">
<em class="property">property </em><code class="sig-name descname">true_center</code><a class="headerlink" href="#galsim.Bounds.true_center" title="Permalink to this definition">¶</a></dt>
<dd><p>The central position of the Bounds as a PositionD.</p>
<p>This is always (xmax + xmin)/2., (ymax + ymin)/2., even for integer BoundsI, where
this may not necessarily be an integer PositionI.</p>
</dd></dl>

<dl class="method">
<dt id="galsim.Bounds.withBorder">
<code class="sig-name descname">withBorder</code><span class="sig-paren">(</span><em class="sig-param">dx</em>, <em class="sig-param">dy=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#Bounds.withBorder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Bounds.withBorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new Bounds object that expands the current bounds by the specified width.</p>
<p>If two arguments are given, then these are separate dx and dy borders.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.BoundsI">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">BoundsI</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#BoundsI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BoundsI" title="Permalink to this definition">¶</a></dt>
<dd><p>A Bounds that takes only integer values.</p>
<p>Typically used to define the bounding box of an image.</p>
<p>See the Bounds doc string for more details.</p>
<dl class="method">
<dt id="galsim.BoundsI.numpyShape">
<code class="sig-name descname">numpyShape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#BoundsI.numpyShape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BoundsI.numpyShape" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple utility function to get the numpy shape that corresponds to this Bounds object.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="galsim.BoundsD">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">BoundsD</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#BoundsD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.BoundsD" title="Permalink to this definition">¶</a></dt>
<dd><p>A Bounds that takes floating point values.</p>
<p>See the Bounds doc string for more details.</p>
</dd></dl>

<dl class="function">
<dt id="galsim._BoundsI">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">_BoundsI</code><span class="sig-paren">(</span><em class="sig-param">xmin</em>, <em class="sig-param">xmax</em>, <em class="sig-param">ymin</em>, <em class="sig-param">ymax</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#_BoundsI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim._BoundsI" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to BoundsI constructor, but skips some sanity checks and argument parsing.
This requires that the four values already be int types.</p>
</dd></dl>

<dl class="function">
<dt id="galsim._BoundsD">
<code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">_BoundsD</code><span class="sig-paren">(</span><em class="sig-param">xmin</em>, <em class="sig-param">xmax</em>, <em class="sig-param">ymin</em>, <em class="sig-param">ymax</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/bounds.html#_BoundsD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim._BoundsD" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to BoundsD constructor, but skips some sanity checks and argument parsing.
This requires that the four values already be int types.</p>
</dd></dl>

</div>
<div class="section" id="positions">
<h2>Positions<a class="headerlink" href="#positions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="galsim.Position">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">Position</code><a class="reference internal" href="_modules/galsim/position.html#Position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.Position" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for representing 2D positions on the plane.</p>
<p>Position is a base class for two slightly different kinds of positions:
PositionD describes positions with floating point values in <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.
PositionI described positions with integer values in <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>In the C++ layer, these are templates, but of course no such thing exists in Python,
so the trailing D or I indicate the type.</p>
<p>Initialization:</p>
<p>For the float-valued position class, example initializations include:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">y</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>And for the integer-valued position class, example initializations include:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionI</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionI</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">PositionD</span><span class="p">(</span> <span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – The x component of the position</p></li>
<li><p><strong>y</strong> – The y component of the position</p></li>
</ul>
</dd>
</dl>
<p>Arithmetic:</p>
<p>Most arithmetic that makes sense for a position is allowed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pos1</span> <span class="o">+</span> <span class="n">pos2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos1</span> <span class="o">-</span> <span class="n">pos2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">/</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">pos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos1</span> <span class="o">+=</span> <span class="n">pos2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos1</span> <span class="o">-=</span> <span class="n">pos2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">*=</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">-=</span> <span class="n">x</span>
</pre></div>
</div>
<p>Note though that the types generally need to match.  For example, you cannot multiply
a PositionI by a float or add a PositionI to a PositionD.</p>
</dd></dl>

<dl class="class">
<dt id="galsim.PositionI">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">PositionI</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/position.html#PositionI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PositionI" title="Permalink to this definition">¶</a></dt>
<dd><p>A Position that takes only integer values.</p>
<p>Typically used for coordinate positions on an image.</p>
<p>See the Position doc string for more details.</p>
</dd></dl>

<dl class="class">
<dt id="galsim.PositionD">
<em class="property">class </em><code class="sig-prename descclassname">galsim.</code><code class="sig-name descname">PositionD</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/galsim/position.html#PositionD"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#galsim.PositionD" title="Permalink to this definition">¶</a></dt>
<dd><p>A Position that takes floating point values.</p>
<p>See the Position doc string for more details.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="sb.html" class="btn btn-neutral float-right" title="Surface Brightness Profiles" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="install.html" class="btn btn-neutral float-left" title="Installation Instructions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, GalSim-developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>